# 📦 套餐模块功能说明文档

## 目录
- [模块概述](#模块概述)
- [系统架构](#系统架构)
- [核心功能](#核心功能)
- [API 接口详情](#api-接口详情)
- [API 测试参数示例](#api-测试参数示例)
- [数据模型](#数据模型)
- [业务逻辑](#业务逻辑)
- [技术实现](#技术实现)
- [使用示例](#使用示例)
- [运营管理](#运营管理)
- [常见问题](#常见问题)

---

## 模块概述

### 🎯 功能定位
套餐模块是婴儿摄影工作室的核心业务模块，负责管理所有摄影服务套餐的信息。该模块定义了不同类型的摄影服务，包括价格、时长、包含内容等关键业务信息，为整个预约和订单系统提供商品基础数据支持。

### 🚀 主要特性
- **完整的套餐管理**: 创建、查询、更新、删除套餐信息
- **灵活的定价策略**: 支持不同价格体系和促销活动
- **详细的服务描述**: 包含套餐内容、时长、特色等详细信息
- **状态管理**: 支持套餐上架、下架等状态控制
- **RESTful API**: 标准化的API接口设计
- **完整的文档**: 基于Swagger的API文档支持

### 📊 业务价值
- 统一管理摄影服务产品线
- 支持灵活的定价和促销策略
- 为客户提供清晰的服务选择
- 支持数据分析和业务决策
- 便于运营团队进行产品管理

---

## 系统架构

### 🏗️ 模块结构
```
src/modules/packages/
├── dto/
│   ├── create-package.dto.ts    # 创建套餐DTO
│   └── update-package.dto.ts    # 更新套餐DTO
├── packages.controller.ts       # 套餐控制器
├── packages.service.ts          # 套餐服务
└── packages.module.ts           # 套餐模块
```

### 🔄 架构层次
1. **控制器层**: 处理HTTP请求，参数验证，响应格式化
2. **服务层**: 业务逻辑处理，数据验证，状态管理
3. **数据访问层**: 通过Prisma进行数据库操作
4. **DTO层**: 数据传输对象，确保类型安全和验证

### 🔗 依赖关系
- **PrismaModule**: 数据库访问服务
- **class-validator**: 数据验证库
- **@nestjs/swagger**: API文档生成
- **@nestjs/common**: NestJS核心装饰器

---

## 核心功能

### 1. 套餐创建
**功能描述**: 创建新的摄影套餐，定义服务内容和价格
- 基本信息设置（名称、描述、价格）
- 服务时长和内容定义
- 默认状态和排序设置
- 数据验证和异常处理

### 2. 套餐查询
**全量查询**: 获取所有套餐列表，支持前台展示和后台管理
**单个查询**: 根据套餐ID获取详细信息
**状态过滤**: 可扩展支持按状态查询（如只查询上架套餐）
**关联查询**: 可查询套餐的订单历史和销售数据

### 3. 套餐更新
**部分更新**: 支持更新套餐的任意字段
**状态管理**: 支持上架、下架等状态变更
**价格调整**: 支持价格和促销信息更新
**内容维护**: 支持服务内容和描述的更新

### 4. 套餐删除
**软删除支持**: 可扩展实现软删除功能
**关联检查**: 删除前检查是否有关联订单
**数据完整性**: 确保删除不影响历史订单数据

---

## API 接口详情

### 📋 接口列表

| 方法 | 路径 | 功能 | 状态码 |
|------|------|------|--------|
| POST | `/packages` | 创建套餐 | 201, 400 |
| GET | `/packages` | 获取所有套餐 | 200, 500 |
| GET | `/packages/:id` | 获取套餐详情 | 200, 404 |
| PATCH | `/packages/:id` | 更新套餐信息 | 200, 400, 404 |
| DELETE | `/packages/:id` | 删除套餐 | 200, 404, 409 |

### 🔍 接口详细说明

#### 1. 创建套餐
```http
POST /packages
Content-Type: application/json

{
  "name": "经典亲子摄影套餐",
  "description": "专业摄影师一对一服务，包含精修照片20张",
  "price": 899.00,
  "duration": 120,
  "features": ["专业摄影师", "精修20张", "服装租赁", "化妆服务"],
  "isActive": true
}
```

**请求参数**:
- `name` (必填): 套餐名称
- `description` (必填): 套餐描述
- `price` (必填): 套餐价格
- `duration` (必填): 服务时长（分钟）
- `features` (可选): 套餐特色列表
- `isActive` (可选): 是否激活，默认true

**响应示例**:
```json
{
  "id": 1,
  "name": "经典亲子摄影套餐",
  "description": "专业摄影师一对一服务，包含精修照片20张",
  "price": 899.00,
  "duration": 120,
  "features": ["专业摄影师", "精修20张", "服装租赁", "化妆服务"],
  "isActive": true,
  "sortOrder": 0,
  "createdAt": "2024-07-25T10:30:00.000Z",
  "updatedAt": "2024-07-25T10:30:00.000Z"
}
```

#### 2. 获取所有套餐
```http
GET /packages
```

**响应示例**:
```json
[
  {
    "id": 1,
    "name": "经典亲子摄影套餐",
    "description": "专业摄影师一对一服务，包含精修照片20张",
    "price": 899.00,
    "duration": 120,
    "features": ["专业摄影师", "精修20张", "服装租赁", "化妆服务"],
    "isActive": true,
    "sortOrder": 0,
    "createdAt": "2024-07-25T10:30:00.000Z",
    "updatedAt": "2024-07-25T10:30:00.000Z"
  },
  {
    "id": 2,
    "name": "豪华全家福套餐",
    "description": "全家福摄影，包含大尺寸相框和相册",
    "price": 1299.00,
    "duration": 180,
    "features": ["全家福拍摄", "大尺寸相框", "精装相册", "服装租赁"],
    "isActive": true,
    "sortOrder": 1,
    "createdAt": "2024-07-25T10:35:00.000Z",
    "updatedAt": "2024-07-25T10:35:00.000Z"
  }
]
```

#### 3. 获取套餐详情
```http
GET /packages/1
```

**响应示例**:
```json
{
  "id": 1,
  "name": "经典亲子摄影套餐",
  "description": "专业摄影师一对一服务，包含精修照片20张",
  "price": 899.00,
  "duration": 120,
  "features": ["专业摄影师", "精修20张", "服装租赁", "化妆服务"],
  "isActive": true,
  "sortOrder": 0,
  "createdAt": "2024-07-25T10:30:00.000Z",
  "updatedAt": "2024-07-25T10:30:00.000Z"
}
```

#### 4. 更新套餐信息
```http
PATCH /packages/1
Content-Type: application/json

{
  "price": 999.00,
  "description": "专业摄影师一对一服务，包含精修照片25张（限时升级）"
}
```

**响应示例**:
```json
{
  "id": 1,
  "name": "经典亲子摄影套餐",
  "description": "专业摄影师一对一服务，包含精修照片25张（限时升级）",
  "price": 999.00,
  "duration": 120,
  "features": ["专业摄影师", "精修20张", "服装租赁", "化妆服务"],
  "isActive": true,
  "sortOrder": 0,
  "createdAt": "2024-07-25T10:30:00.000Z",
  "updatedAt": "2024-07-25T11:00:00.000Z"
}
```

#### 5. 删除套餐
```http
DELETE /packages/1
```

**响应示例**:
```json
{
  "message": "套餐删除成功",
  "deletedId": 1
}
```

### 🧪 API 测试参数示例

本部分提供了可在 Swagger UI (`/api/docs`) 中直接使用的测试参数。

#### 1. 创建套餐 (POST /packages)

**示例1: 基础套餐**
```json
{
  "name": "新生儿纪念套餐",
  "description": "记录宝宝初生时刻的珍贵瞬间，包含10张精修照片。",
  "price": 599,
  "duration": 60,
  "features": ["新生儿专属道具", "安全舒适环境", "专业引导师"],
  "isActive": true,
  "sortOrder": 10
}
```

**示例2: 高级套餐**
```json
{
  "name": "百日宴豪华套餐",
  "description": "庆祝宝宝百日，全家福拍摄，赠送定制相册。",
  "price": 1599,
  "duration": 120,
  "features": ["全家福拍摄", "定制相册", "多套服装造型", "化妆服务"],
  "isActive": true,
  "sortOrder": 20
}
```

#### 2. 获取所有套餐 (GET /packages)

此接口无需参数。

#### 3. 获取套餐详情 (GET /packages/:id)

- **id**: `1` (请使用一个已存在的套餐ID)

#### 4. 更新套餐信息 (PATCH /packages/:id)

- **id**: `1` (请使用一个已存在的套餐ID)

**请求体示例:**
```json
{
  "price": 699,
  "description": "记录宝宝初生时刻的珍贵瞬间，升级包含15张精修照片。",
  "isActive": false
}
```

#### 5. 删除套餐 (DELETE /packages/:id)

- **id**: `2` (请使用一个已存在的、且没有关联订单的套餐ID)

---

## 数据模型

### 📊 套餐数据结构
```typescript
interface Package {
  id: number;          // 主键ID
  name: string;        // 套餐名称
  description: string; // 套餐描述
  price: number;       // 套餐价格
  duration: number;    // 服务时长（分钟）
  features?: string[]; // 套餐特色列表
  isActive: boolean;   // 是否激活
  sortOrder: number;   // 排序权重
  createdAt: Date;     // 创建时间
  updatedAt: Date;     // 更新时间
  
  // 关联关系
  orders?: Order[];    // 使用该套餐的订单列表
}
```

### 🔗 关联关系
- **一对多**: Package → Order (一个套餐可以被多个订单使用)
- **一对多**: Package → Payment (通过订单关联支付记录)
- **一对多**: Package → TimeSlot (通过订单关联时间槽)

### 📝 DTO 结构

#### CreatePackageDto
```typescript
{
  name: string;        // 必填，套餐名称
  description: string; // 必填，套餐描述
  price: number;       // 必填，套餐价格
  duration: number;    // 必填，服务时长
  features?: string[]; // 可选，特色列表
  isActive?: boolean;  // 可选，是否激活
  sortOrder?: number;  // 可选，排序权重
}
```

#### UpdatePackageDto
```typescript
{
  name?: string;       // 可选，套餐名称
  description?: string;// 可选，套餐描述
  price?: number;      // 可选，套餐价格
  duration?: number;   // 可选，服务时长
  features?: string[]; // 可选，特色列表
  isActive?: boolean;  // 可选，是否激活
  sortOrder?: number;  // 可选，排序权重
}
```

---

## 业务逻辑

### 🛡️ 数据验证规则

#### 1. 创建套餐验证
- **name**: 必填，字符串类型，长度限制1-100字符
- **description**: 必填，字符串类型，长度限制1-500字符
- **price**: 必填，数字类型，必须大于0
- **duration**: 必填，整数类型，必须大于0（分钟）
- **features**: 可选，字符串数组
- **isActive**: 可选，布尔类型，默认true
- **sortOrder**: 可选，整数类型，默认0

#### 2. 更新套餐验证
- 所有字段都是可选的
- 字段类型验证与创建时相同
- 至少需要提供一个字段进行更新

#### 3. 业务规则
- **价格策略**: 价格必须为正数，支持小数点后两位
- **时长策略**: 时长必须为正整数，建议最小30分钟
- **状态管理**: 下架的套餐不能被新订单选择
- **完整性**: 删除套餐前需检查关联订单

### 🔄 状态管理
```typescript
enum PackageStatus {
  ACTIVE = true,    // 激活状态，可以被选择
  INACTIVE = false  // 停用状态，不可被选择
}
```

### 💰 定价策略
- **基础定价**: 设定套餐基础价格
- **促销定价**: 可通过更新接口调整促销价格
- **动态定价**: 可扩展实现基于时间、需求的动态定价
- **会员定价**: 可扩展实现会员优惠价格体系

---

## 技术实现

### 🔧 核心技术栈
- **NestJS**: Web框架和依赖注入
- **Prisma**: ORM数据库访问
- **TypeScript**: 类型安全
- **class-validator**: 数据验证
- **Swagger**: API文档生成

### 📋 服务实现
```typescript
@Injectable()
export class PackagesService {
  constructor(private readonly prisma: PrismaService) {}

  async create(createPackageDto: CreatePackageDto): Promise<Package> {
    try {
      return await this.prisma.package.create({
        data: {
          ...createPackageDto,
          sortOrder: createPackageDto.sortOrder || 0,
        },
      });
    } catch (error) {
      throw new BadRequestException(`Failed to create package: ${error.message}`);
    }
  }

  async findAll(): Promise<Package[]> {
    try {
      return await this.prisma.package.findMany({
        orderBy: [
          { sortOrder: 'asc' },
          { createdAt: 'desc' }
        ]
      });
    } catch (error) {
      throw new InternalServerErrorException(`Failed to fetch packages: ${error.message}`);
    }
  }

  async findActive(): Promise<Package[]> {
    return await this.prisma.package.findMany({
      where: { isActive: true },
      orderBy: [
        { sortOrder: 'asc' },
        { createdAt: 'desc' }
      ]
    });
  }
}
```

### 🗄️ 数据库操作

#### 创建套餐
```typescript
await this.prisma.package.create({
  data: {
    name: dto.name,
    description: dto.description,
    price: dto.price,
    duration: dto.duration,
    features: dto.features || [],
    isActive: dto.isActive ?? true,
    sortOrder: dto.sortOrder || 0,
  },
});
```

#### 查询套餐（包含销售统计）
```typescript
await this.prisma.package.findMany({
  include: {
    orders: {
      select: {
        id: true,
        status: true,
        createdAt: true,
      },
    },
    _count: {
      select: {
        orders: true,
      },
    },
  },
});
```

### 🚦 异常处理
```typescript
// 自定义异常处理
try {
  return await this.prisma.package.findUnique({ where: { id } });
} catch (error) {
  if (error.code === 'P2025') { // Prisma记录不存在
    throw new NotFoundException('套餐不存在');
  }
  throw new InternalServerErrorException('查询套餐失败');
}

// 删除前关联检查
async remove(id: number) {
  const packageWithOrders = await this.prisma.package.findUnique({
    where: { id },
    include: { _count: { select: { orders: true } } }
  });

  if (!packageWithOrders) {
    throw new NotFoundException('套餐不存在');
  }

  if (packageWithOrders._count.orders > 0) {
    throw new ConflictException('套餐已被使用，无法删除');
  }

  return await this.prisma.package.delete({ where: { id } });
}
```

---

## 使用示例

### 🎯 前端集成示例

#### 微信小程序套餐展示
```javascript
// 获取套餐列表
Page({
  data: {
    packages: [],
    loading: true
  },

  onLoad() {
    this.loadPackages();
  },

  async loadPackages() {
    try {
      const res = await wx.request({
        url: 'https://api.example.com/packages',
        method: 'GET'
      });

      this.setData({
        packages: res.data.filter(pkg => pkg.isActive),
        loading: false
      });
    } catch (error) {
      wx.showToast({
        title: '加载失败',
        icon: 'error'
      });
    }
  },

  selectPackage(e) {
    const packageId = e.currentTarget.dataset.id;
    const selectedPackage = this.data.packages.find(pkg => pkg.id === packageId);
    
    // 保存选中的套餐信息
    wx.setStorageSync('selectedPackage', selectedPackage);
    
    // 跳转到预约页面
    wx.navigateTo({
      url: `/pages/booking/booking?packageId=${packageId}`
    });
  }
});
```

```html
<!-- 套餐展示页面 -->
<view class="packages-container">
  <view wx:if="{{loading}}" class="loading">加载中...</view>
  
  <view wx:else class="packages-list">
    <view 
      wx:for="{{packages}}" 
      wx:key="id" 
      class="package-item"
      data-id="{{item.id}}"
      bindtap="selectPackage"
    >
      <view class="package-header">
        <text class="package-name">{{item.name}}</text>
        <text class="package-price">¥{{item.price}}</text>
      </view>
      
      <view class="package-description">{{item.description}}</view>
      
      <view class="package-duration">拍摄时长：{{item.duration}}分钟</view>
      
      <view class="package-features">
        <text 
          wx:for="{{item.features}}" 
          wx:key="index" 
          class="feature-tag"
        >
          {{item}}
        </text>
      </view>
    </view>
  </view>
</view>
```

#### React 套餐管理组件
```typescript
// 套餐服务类
class PackageService {
  private baseURL = '/api/packages';

  async getAllPackages(): Promise<Package[]> {
    const response = await fetch(this.baseURL);
    if (!response.ok) throw new Error('获取套餐列表失败');
    return response.json();
  }

  async createPackage(packageData: CreatePackageDto): Promise<Package> {
    const response = await fetch(this.baseURL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(packageData),
    });
    if (!response.ok) throw new Error('创建套餐失败');
    return response.json();
  }

  async updatePackage(id: number, updateData: UpdatePackageDto): Promise<Package> {
    const response = await fetch(`${this.baseURL}/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updateData),
    });
    if (!response.ok) throw new Error('更新套餐失败');
    return response.json();
  }

  async deletePackage(id: number): Promise<void> {
    const response = await fetch(`${this.baseURL}/${id}`, {
      method: 'DELETE',
    });
    if (!response.ok) throw new Error('删除套餐失败');
  }
}

// React Hook
function usePackages() {
  const [packages, setPackages] = useState<Package[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const packageService = new PackageService();

  const fetchPackages = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const data = await packageService.getAllPackages();
      setPackages(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : '获取套餐失败');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchPackages();
  }, [fetchPackages]);

  const createPackage = async (packageData: CreatePackageDto) => {
    try {
      const newPackage = await packageService.createPackage(packageData);
      setPackages(prev => [...prev, newPackage]);
      return newPackage;
    } catch (err) {
      setError(err instanceof Error ? err.message : '创建失败');
      throw err;
    }
  };

  const updatePackage = async (id: number, updateData: UpdatePackageDto) => {
    try {
      const updatedPackage = await packageService.updatePackage(id, updateData);
      setPackages(prev => prev.map(pkg => 
        pkg.id === id ? updatedPackage : pkg
      ));
      return updatedPackage;
    } catch (err) {
      setError(err instanceof Error ? err.message : '更新失败');
      throw err;
    }
  };

  const deletePackage = async (id: number) => {
    try {
      await packageService.deletePackage(id);
      setPackages(prev => prev.filter(pkg => pkg.id !== id));
    } catch (err) {
      setError(err instanceof Error ? err.message : '删除失败');
      throw err;
    }
  };

  return {
    packages,
    loading,
    error,
    createPackage,
    updatePackage,
    deletePackage,
    refetch: fetchPackages,
  };
}

// 套餐管理组件
function PackageManagement() {
  const { packages, loading, error, createPackage, updatePackage, deletePackage } = usePackages();
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [editingPackage, setEditingPackage] = useState<Package | null>(null);

  const handleCreate = async (packageData: CreatePackageDto) => {
    try {
      await createPackage(packageData);
      setIsCreateModalOpen(false);
      alert('套餐创建成功');
    } catch (error) {
      alert('创建失败');
    }
  };

  const handleUpdate = async (updateData: UpdatePackageDto) => {
    if (!editingPackage) return;
    
    try {
      await updatePackage(editingPackage.id, updateData);
      setEditingPackage(null);
      alert('套餐更新成功');
    } catch (error) {
      alert('更新失败');
    }
  };

  const handleDelete = async (id: number) => {
    if (!confirm('确定要删除这个套餐吗？')) return;
    
    try {
      await deletePackage(id);
      alert('套餐删除成功');
    } catch (error) {
      alert('删除失败');
    }
  };

  if (loading) return <div>加载中...</div>;
  if (error) return <div>错误: {error}</div>;

  return (
    <div>
      <div className="header">
        <h1>套餐管理</h1>
        <button onClick={() => setIsCreateModalOpen(true)}>
          新增套餐
        </button>
      </div>

      <div className="packages-grid">
        {packages.map(pkg => (
          <div key={pkg.id} className="package-card">
            <div className="package-header">
              <h3>{pkg.name}</h3>
              <span className="price">¥{pkg.price}</span>
            </div>
            
            <p className="description">{pkg.description}</p>
            
            <div className="package-info">
              <span>时长: {pkg.duration}分钟</span>
              <span className={`status ${pkg.isActive ? 'active' : 'inactive'}`}>
                {pkg.isActive ? '已上架' : '已下架'}
              </span>
            </div>

            <div className="features">
              {pkg.features?.map((feature, index) => (
                <span key={index} className="feature-tag">{feature}</span>
              ))}
            </div>

            <div className="actions">
              <button onClick={() => setEditingPackage(pkg)}>编辑</button>
              <button 
                onClick={() => handleDelete(pkg.id)}
                className="delete-btn"
              >
                删除
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* 创建/编辑模态框组件 */}
      <PackageModal
        isOpen={isCreateModalOpen || !!editingPackage}
        package={editingPackage}
        onSubmit={editingPackage ? handleUpdate : handleCreate}
        onClose={() => {
          setIsCreateModalOpen(false);
          setEditingPackage(null);
        }}
      />
    </div>
  );
}
```

---

## 运营管理

### 📊 套餐销售分析
```typescript
// 销售统计服务
class PackageAnalyticsService {
  async getPackageStats(startDate: string, endDate: string) {
    const packages = await this.prisma.package.findMany({
      include: {
        orders: {
          where: {
            createdAt: {
              gte: new Date(startDate),
              lte: new Date(endDate),
            },
            status: 'COMPLETED',
          },
        },
      },
    });

    return packages.map(pkg => ({
      id: pkg.id,
      name: pkg.name,
      price: pkg.price,
      totalOrders: pkg.orders.length,
      totalRevenue: pkg.orders.length * pkg.price,
      averageOrdersPerDay: pkg.orders.length / this.getDaysBetween(startDate, endDate),
    }));
  }

  async getTopPackages(limit = 5) {
    return await this.prisma.package.findMany({
      include: {
        _count: {
          select: { orders: true },
        },
      },
      orderBy: {
        orders: {
          _count: 'desc',
        },
      },
      take: limit,
    });
  }
}

// 套餐表现分析组件
function PackageAnalytics() {
  const [stats, setStats] = useState([]);
  const [topPackages, setTopPackages] = useState([]);
  const [dateRange, setDateRange] = useState({
    start: format(subDays(new Date(), 30), 'yyyy-MM-dd'),
    end: format(new Date(), 'yyyy-MM-dd'),
  });

  const analyticsService = new PackageAnalyticsService();

  useEffect(() => {
    Promise.all([
      analyticsService.getPackageStats(dateRange.start, dateRange.end),
      analyticsService.getTopPackages(),
    ]).then(([statsData, topData]) => {
      setStats(statsData);
      setTopPackages(topData);
    });
  }, [dateRange]);

  return (
    <div>
      <h2>套餐销售分析</h2>
      
      <div className="date-picker">
        <input
          type="date"
          value={dateRange.start}
          onChange={(e) => setDateRange({...dateRange, start: e.target.value})}
        />
        <input
          type="date"
          value={dateRange.end}
          onChange={(e) => setDateRange({...dateRange, end: e.target.value})}
        />
      </div>

      <div className="stats-grid">
        {stats.map(stat => (
          <div key={stat.id} className="stat-card">
            <h3>{stat.name}</h3>
            <div className="stat-row">
              <span>订单数量:</span>
              <span>{stat.totalOrders}</span>
            </div>
            <div className="stat-row">
              <span>总收入:</span>
              <span>¥{stat.totalRevenue}</span>
            </div>
            <div className="stat-row">
              <span>日均订单:</span>
              <span>{stat.averageOrdersPerDay.toFixed(1)}</span>
            </div>
          </div>
        ))}
      </div>

      <div className="top-packages">
        <h3>最受欢迎套餐</h3>
        {topPackages.map((pkg, index) => (
          <div key={pkg.id} className="top-package-item">
            <span className="rank">#{index + 1}</span>
            <span className="name">{pkg.name}</span>
            <span className="orders">{pkg._count.orders} 订单</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 🏷️ 促销活动管理
```typescript
// 促销活动扩展
interface PackagePromotion {
  id: number;
  packageId: number;
  title: string;
  discountType: 'PERCENTAGE' | 'FIXED_AMOUNT';
  discountValue: number;
  startDate: Date;
  endDate: Date;
  isActive: boolean;
}

// 促销价格计算
function calculatePromotionPrice(originalPrice: number, promotion: PackagePromotion): number {
  if (!promotion.isActive) return originalPrice;
  
  const now = new Date();
  if (now < promotion.startDate || now > promotion.endDate) {
    return originalPrice;
  }
  
  if (promotion.discountType === 'PERCENTAGE') {
    return originalPrice * (1 - promotion.discountValue / 100);
  } else {
    return Math.max(0, originalPrice - promotion.discountValue);
  }
}

// 带促销信息的套餐查询
async function getPackagesWithPromotions() {
  const packages = await this.prisma.package.findMany({
    include: {
      promotions: {
        where: {
          isActive: true,
          startDate: { lte: new Date() },
          endDate: { gte: new Date() },
        },
      },
    },
  });

  return packages.map(pkg => ({
    ...pkg,
    originalPrice: pkg.price,
    currentPrice: pkg.promotions.length > 0 
      ? calculatePromotionPrice(pkg.price, pkg.promotions[0])
      : pkg.price,
    hasPromotion: pkg.promotions.length > 0,
  }));
}
```

---

## 常见问题

### ❓ FAQ

#### Q1: 如何实现套餐的分类管理？
**A**: 可以扩展Package模型添加category字段，实现套餐分类。

```typescript
// 扩展Prisma模型
model Package {
  id          Int      @id @default(autoincrement())
  name        String
  description String
  price       Float
  duration    Int
  categoryId  Int?     // 分类ID
  category    Category? @relation(fields: [categoryId], references: [id])
  // ... 其他字段
}

model Category {
  id       Int       @id @default(autoincrement())
  name     String
  packages Package[]
}

// 按分类查询套餐
async findByCategory(categoryId: number) {
  return await this.prisma.package.findMany({
    where: { categoryId },
    include: { category: true }
  });
}
```

#### Q2: 如何实现套餐的库存管理？
**A**: 可以添加库存字段，限制同时预约的数量。

```typescript
// 扩展套餐模型
model Package {
  // ... 现有字段
  stockLimit    Int?     // 库存限制（null表示无限制）
  currentStock  Int      @default(0) // 当前库存
}

// 检查库存可用性
async checkStockAvailability(packageId: number, date: string): Promise<boolean> {
  const package = await this.prisma.package.findUnique({
    where: { id: packageId },
    include: {
      orders: {
        where: {
          timeSlot: {
            date: new Date(date)
          },
          status: { in: ['PENDING', 'CONFIRMED'] }
        }
      }
    }
  });

  if (!package.stockLimit) return true; // 无库存限制
  
  const bookedCount = package.orders.length;
  return bookedCount < package.stockLimit;
}
```

#### Q3: 如何实现套餐的多规格支持？
**A**: 可以创建套餐变体（PackageVariant）模型。

```typescript
model Package {
  id       Int              @id @default(autoincrement())
  name     String
  // ... 基础字段
  variants PackageVariant[]
}

model PackageVariant {
  id        Int     @id @default(autoincrement())
  packageId Int
  name      String  // 规格名称，如"基础版"、"豪华版"
  price     Float   // 该规格的价格
  duration  Int     // 该规格的时长
  features  String[] // 该规格的特色
  package   Package @relation(fields: [packageId], references: [id])
}
```

#### Q4: 如何实现套餐的季节性定价？
**A**: 可以添加定价规则表，根据时间段调整价格。

```typescript
model PricingRule {
  id          Int      @id @default(autoincrement())
  packageId   Int
  startDate   DateTime
  endDate     DateTime
  priceType   String   // 'PERCENTAGE' | 'FIXED_AMOUNT'
  priceValue  Float    // 调整值
  isActive    Boolean  @default(true)
  package     Package  @relation(fields: [packageId], references: [id])
}

// 计算动态价格
async calculateDynamicPrice(packageId: number, date: Date): Promise<number> {
  const package = await this.prisma.package.findUnique({
    where: { id: packageId },
    include: {
      pricingRules: {
        where: {
          isActive: true,
          startDate: { lte: date },
          endDate: { gte: date }
        }
      }
    }
  });

  let finalPrice = package.price;
  
  package.pricingRules.forEach(rule => {
    if (rule.priceType === 'PERCENTAGE') {
      finalPrice *= (1 + rule.priceValue / 100);
    } else {
      finalPrice += rule.priceValue;
    }
  });

  return Math.max(0, finalPrice);
}
```

#### Q5: 如何实现套餐的组合优惠？
**A**: 可以创建套餐组合表，定义组合优惠规则。

```typescript
model PackageCombo {
  id          Int     @id @default(autoincrement())
  name        String
  packageIds  Int[]   // 组合的套餐ID列表
  discountType String // 'PERCENTAGE' | 'FIXED_AMOUNT'
  discountValue Float
  isActive    Boolean @default(true)
}

// 计算组合优惠价格
async function calculateComboPrice(packageIds: number[]): Promise<ComboResult> {
  const packages = await this.prisma.package.findMany({
    where: { id: { in: packageIds } }
  });

  const originalTotal = packages.reduce((sum, pkg) => sum + pkg.price, 0);

  const combo = await this.prisma.packageCombo.findFirst({
    where: {
      isActive: true,
      packageIds: { hasEvery: packageIds }
    }
  });

  if (!combo) {
    return { originalPrice: originalTotal, finalPrice: originalTotal, savings: 0 };
  }

  let finalPrice = originalTotal;
  if (combo.discountType === 'PERCENTAGE') {
    finalPrice = originalTotal * (1 - combo.discountValue / 100);
  } else {
    finalPrice = originalTotal - combo.discountValue;
  }

  return {
    originalPrice: originalTotal,
    finalPrice: Math.max(0, finalPrice),
    savings: originalTotal - finalPrice,
    comboName: combo.name
  };
}
```

### 🐛 故障排除

#### 常见错误及解决方案

1. **套餐创建失败**
   ```
   错误: Failed to create package: Invalid price value
   解决: 检查价格是否为正数，确保数据类型正确
   ```

2. **套餐不存在**
   ```
   错误: Package with id 1 not found
   解决: 检查套餐ID是否正确，确认套餐未被删除
   ```

3. **删除失败**
   ```
   错误: 套餐已被使用，无法删除
   解决: 检查是否有关联订单，考虑使用软删除或停用功能
   ```

---

## 总结

套餐模块是业务系统的核心产品管理模块，提供了：

✅ **完整的套餐管理**: 从创建到删除的全生命周期管理  
✅ **灵活的定价策略**: 支持多种定价和促销机制  
✅ **丰富的扩展性**: 支持分类、规格、库存等高级功能  
✅ **数据驱动决策**: 提供详细的销售分析和统计功能  
✅ **用户友好界面**: 完整的前端集成示例和最佳实践  
✅ **运营管理支持**: 促销活动、库存管理等运营工具  

该模块为婴儿摄影工作室提供了专业、灵活的产品管理解决方案，支持各种业务场景和运营需求。

---

*文档版本: 1.0.0*  
*最后更新: 2024年7月25日*  
*维护者: 开发团队*

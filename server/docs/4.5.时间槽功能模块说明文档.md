# ğŸ“… æ—¶é—´æ§½åŠŸèƒ½æ¨¡å—è¯´æ˜æ–‡æ¡£

## ç›®å½•
- [æ¨¡å—æ¦‚è¿°](#æ¨¡å—æ¦‚è¿°)
- [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
- [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
- [API æ¥å£è¯¦æƒ…](#api-æ¥å£è¯¦æƒ…)
- [æ•°æ®æ¨¡å‹](#æ•°æ®æ¨¡å‹)
- [ä¸šåŠ¡é€»è¾‘](#ä¸šåŠ¡é€»è¾‘)
- [æŠ€æœ¯å®ç°](#æŠ€æœ¯å®ç°)
- [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
- [éƒ¨ç½²å’Œè¿ç»´](#éƒ¨ç½²å’Œè¿ç»´)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

---

## æ¨¡å—æ¦‚è¿°

### ğŸ¯ åŠŸèƒ½å®šä½
æ—¶é—´æ§½æ¨¡å—æ˜¯å©´å„¿æ‘„å½±å·¥ä½œå®¤é¢„çº¦ç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£ç®¡ç†æ‰€æœ‰å¯é¢„çº¦çš„æ—¶é—´æ®µã€‚è¯¥æ¨¡å—æä¾›äº†å®Œæ•´çš„æ—¶é—´æ§½ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ŒåŒ…æ‹¬åˆ›å»ºã€æŸ¥è¯¢ã€æ›´æ–°å’Œåˆ é™¤åŠŸèƒ½ï¼Œå¹¶æ”¯æŒæ™ºèƒ½æ‰¹é‡æ“ä½œã€‚

### ğŸš€ ä¸»è¦ç‰¹æ€§
- **å®Œæ•´çš„æ—¶é—´æ§½ç®¡ç†**: æ”¯æŒå•ä¸ªå’Œæ‰¹é‡æ—¶é—´æ§½çš„åˆ›å»ºã€æŸ¥è¯¢ã€æ›´æ–°ã€åˆ é™¤
- **æ™ºèƒ½å†²çªæ£€æµ‹**: è‡ªåŠ¨æ£€æµ‹æ—¶é—´æ§½å†²çªï¼Œé˜²æ­¢é‡å¤é¢„è®¢
- **çµæ´»çš„æŸ¥è¯¢ç³»ç»Ÿ**: æ”¯æŒæ—¥æœŸèŒƒå›´ã€çŠ¶æ€è¿‡æ»¤ã€å¤šç§æ’åºæ–¹å¼
- **ä¸šåŠ¡é€»è¾‘ä¿æŠ¤**: ä¸¥æ ¼çš„æ—¶é—´éªŒè¯å’Œå…³è”æ•°æ®ä¿æŠ¤
- **æ‰¹é‡æ“ä½œæ”¯æŒ**: é«˜æ•ˆçš„æ‰¹é‡åˆ›å»ºå’Œç®¡ç†åŠŸèƒ½
- **å®Œæ•´çš„APIæ–‡æ¡£**: åŸºäº Swagger çš„è¯¦ç»†APIæ–‡æ¡£

### ğŸ“Š ä¸šåŠ¡ä»·å€¼
- æé«˜å·¥ä½œå®¤è¿è¥æ•ˆç‡
- å‡å°‘é¢„çº¦å†²çªå’Œå®¢æˆ·æŠ•è¯‰
- æ”¯æŒçµæ´»çš„æ—¶é—´ç®¡ç†ç­–ç•¥
- æä¾›è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒ
- ä¾¿äºæ•°æ®åˆ†æå’Œä¸šåŠ¡ä¼˜åŒ–

---

## ç³»ç»Ÿæ¶æ„

### ğŸ—ï¸ æ¨¡å—ç»“æ„
```
src/modules/time-slots/
â”œâ”€â”€ dto/                              # æ•°æ®ä¼ è¾“å¯¹è±¡
â”‚   â”œâ”€â”€ create-time-slot.dto.ts       # åˆ›å»ºæ—¶é—´æ§½DTO
â”‚   â”œâ”€â”€ update-time-slot.dto.ts       # æ›´æ–°æ—¶é—´æ§½DTO
â”‚   â”œâ”€â”€ query-time-slots.dto.ts       # æŸ¥è¯¢æ—¶é—´æ§½DTO
â”‚   â””â”€â”€ create-batch-time-slots.dto.ts # æ‰¹é‡åˆ›å»ºDTO
â”œâ”€â”€ time-slots.controller.ts          # æ§åˆ¶å™¨å±‚
â”œâ”€â”€ time-slots.service.ts             # æœåŠ¡å±‚
â””â”€â”€ time-slots.module.ts              # æ¨¡å—é…ç½®
```

### ğŸ”„ æ¶æ„å±‚æ¬¡
1. **æ§åˆ¶å™¨å±‚ (Controller)**: å¤„ç†HTTPè¯·æ±‚ï¼Œå‚æ•°éªŒè¯ï¼Œå“åº”æ ¼å¼åŒ–
2. **æœåŠ¡å±‚ (Service)**: ä¸šåŠ¡é€»è¾‘å¤„ç†ï¼Œæ•°æ®éªŒè¯ï¼Œäº‹åŠ¡ç®¡ç†
3. **æ•°æ®è®¿é—®å±‚ (Prisma)**: æ•°æ®åº“æ“ä½œï¼Œå…³è”æŸ¥è¯¢ï¼Œäº‹åŠ¡å¤„ç†
4. **DTOå±‚**: æ•°æ®ä¼ è¾“å’ŒéªŒè¯ï¼ŒAPIæ–‡æ¡£ç”Ÿæˆ

### ğŸ”— ä¾èµ–å…³ç³»
- **PrismaModule**: æ•°æ®åº“è®¿é—®æœåŠ¡
- **class-validator**: æ•°æ®éªŒè¯
- **@nestjs/swagger**: APIæ–‡æ¡£ç”Ÿæˆ
- **@nestjs/common**: æ ¸å¿ƒè£…é¥°å™¨å’Œå¼‚å¸¸

---

## æ ¸å¿ƒåŠŸèƒ½

### 1. æ—¶é—´æ§½åˆ›å»º
**å•ä¸ªåˆ›å»º**:
- éªŒè¯æ—¶é—´æ ¼å¼å’Œæœ‰æ•ˆæ€§
- æ£€æµ‹æ—¶é—´æ§½å†²çª
- æ‰§è¡Œä¸šåŠ¡è§„åˆ™éªŒè¯
- åˆ›å»ºæ•°æ®åº“è®°å½•

**æ‰¹é‡åˆ›å»º**:
- æ”¯æŒå¤šæ—¥æœŸå¤šæ—¶é—´æ®µ
- äº‹åŠ¡å¤„ç†ä¿è¯ä¸€è‡´æ€§
- è‡ªåŠ¨è·³è¿‡é‡å¤æ—¶é—´æ§½
- è¿”å›åˆ›å»ºç»“æœç»Ÿè®¡

### 2. æ—¶é—´æ§½æŸ¥è¯¢
**åŸºç¡€æŸ¥è¯¢**:
- æ ¹æ®IDè·å–è¯¦æƒ…
- è·å–æ‰€æœ‰æ—¶é—´æ§½åˆ—è¡¨
- åŒ…å«å…³è”è®¢å•ä¿¡æ¯

**é«˜çº§æŸ¥è¯¢**:
- æ—¥æœŸèŒƒå›´è¿‡æ»¤
- é¢„è®¢çŠ¶æ€è¿‡æ»¤
- å¤šç§æ’åºé€‰é¡¹
- å¯ç”¨æ—¶é—´æ§½æŸ¥è¯¢

### 3. æ—¶é—´æ§½æ›´æ–°
- éƒ¨åˆ†å­—æ®µæ›´æ–°
- é¢„è®¢çŠ¶æ€å˜æ›´
- æ—¶é—´è°ƒæ•´ï¼ˆå«å†²çªæ£€æµ‹ï¼‰
- å…³è”æ•°æ®åŒæ­¥

### 4. æ—¶é—´æ§½åˆ é™¤
- å…³è”è®¢å•æ£€æŸ¥
- çº§è”åˆ é™¤ä¿æŠ¤
- è½¯åˆ é™¤æ”¯æŒ
- æ•°æ®å®Œæ•´æ€§ç»´æŠ¤

---

## API æ¥å£è¯¦æƒ…

### ğŸ“‹ æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | åŠŸèƒ½ | çŠ¶æ€ç  |
|------|------|------|--------|
| POST | `/time-slots` | åˆ›å»ºå•ä¸ªæ—¶é—´æ§½ | 201, 400, 409 |
| POST | `/time-slots/batch` | æ‰¹é‡åˆ›å»ºæ—¶é—´æ§½ | 201, 400 |
| GET | `/time-slots` | è·å–æ—¶é—´æ§½åˆ—è¡¨ | 200, 400 |
| GET | `/time-slots/available` | è·å–å¯ç”¨æ—¶é—´æ§½ | 200, 400 |
| GET | `/time-slots/:id` | è·å–æ—¶é—´æ§½è¯¦æƒ… | 200, 404 |
| PATCH | `/time-slots/:id` | æ›´æ–°æ—¶é—´æ§½ | 200, 400, 404 |
| DELETE | `/time-slots/:id` | åˆ é™¤æ—¶é—´æ§½ | 200, 400, 404, 409 |

### ğŸ” æ¥å£è¯¦ç»†è¯´æ˜

#### 1. åˆ›å»ºå•ä¸ªæ—¶é—´æ§½
```http
POST /time-slots
Content-Type: application/json

{
  "date": "2024-08-15",
  "startTime": "09:00:00",
  "endTime": "11:00:00"
}
```

**å“åº”ç¤ºä¾‹**:
```json
{
  "id": 1,
  "date": "2024-08-15T00:00:00.000Z",
  "startTime": "1970-01-01T09:00:00.000Z",
  "endTime": "1970-01-01T11:00:00.000Z",
  "isBooked": false,
  "createdAt": "2024-07-25T10:30:00.000Z",
  "updatedAt": "2024-07-25T10:30:00.000Z"
}
```

#### 2. æ‰¹é‡åˆ›å»ºæ—¶é—´æ§½
```http
POST /time-slots/batch
Content-Type: application/json

{
  "dates": ["2024-08-15", "2024-08-16"],
  "timeRanges": [
    { "startTime": "09:00:00", "endTime": "11:00:00" },
    { "startTime": "14:00:00", "endTime": "16:00:00" }
  ]
}
```

**å“åº”ç¤ºä¾‹**:
```json
{
  "created": [
    {
      "id": 1,
      "date": "2024-08-15T00:00:00.000Z",
      "startTime": "1970-01-01T09:00:00.000Z",
      "endTime": "1970-01-01T11:00:00.000Z",
      "isBooked": false
    }
  ],
  "skipped": 1,
  "total": 4
}
```

#### 3. æ¡ä»¶æŸ¥è¯¢æ—¶é—´æ§½
```http
GET /time-slots?startDate=2024-08-15&endDate=2024-08-30&isBooked=false&sortBy=date_asc
```

**æŸ¥è¯¢å‚æ•°**:
- `startDate`: å¼€å§‹æ—¥æœŸ (YYYY-MM-DD)
- `endDate`: ç»“æŸæ—¥æœŸ (YYYY-MM-DD)
- `isBooked`: é¢„è®¢çŠ¶æ€ (true/false)
- `sortBy`: æ’åºæ–¹å¼ (date_asc, date_desc, time_asc, time_desc)

#### 4. è·å–å¯ç”¨æ—¶é—´æ§½
```http
GET /time-slots/available?date=2024-08-15
```

**å“åº”ç¤ºä¾‹**:
```json
[
  {
    "id": 1,
    "date": "2024-08-15T00:00:00.000Z",
    "startTime": "1970-01-01T09:00:00.000Z",
    "endTime": "1970-01-01T11:00:00.000Z",
    "isBooked": false
  }
]
```

---

## æ•°æ®æ¨¡å‹

### ğŸ“Š æ—¶é—´æ§½æ•°æ®ç»“æ„
```typescript
interface TimeSlot {
  id: number;           // ä¸»é”®ID
  date: Date;           // é¢„çº¦æ—¥æœŸ
  startTime: Date;      // å¼€å§‹æ—¶é—´
  endTime: Date;        // ç»“æŸæ—¶é—´
  isBooked: boolean;    // æ˜¯å¦å·²é¢„è®¢
  createdAt: Date;      // åˆ›å»ºæ—¶é—´
  updatedAt: Date;      // æ›´æ–°æ—¶é—´
  
  // å…³è”å…³ç³»
  order?: Order;        // å…³è”çš„è®¢å•
}
```

### ğŸ”— å…³è”å…³ç³»
- **ä¸€å¯¹ä¸€**: TimeSlot â†â†’ Order (ä¸€ä¸ªæ—¶é—´æ§½å¯¹åº”ä¸€ä¸ªè®¢å•)
- **å¤šå¯¹ä¸€**: TimeSlot â†’ User (é€šè¿‡è®¢å•å…³è”ç”¨æˆ·)
- **å¤šå¯¹ä¸€**: TimeSlot â†’ Package (é€šè¿‡è®¢å•å…³è”å¥—é¤)

### ğŸ“ DTO ç»“æ„

#### CreateTimeSlotDto
```typescript
{
  date: string;        // YYYY-MM-DD æ ¼å¼
  startTime: string;   // HH:MM:SS æ ¼å¼
  endTime: string;     // HH:MM:SS æ ¼å¼
}
```

#### UpdateTimeSlotDto
```typescript
{
  date?: string;       // å¯é€‰ï¼Œæ—¥æœŸ
  startTime?: string;  // å¯é€‰ï¼Œå¼€å§‹æ—¶é—´
  endTime?: string;    // å¯é€‰ï¼Œç»“æŸæ—¶é—´
  isBooked?: boolean;  // å¯é€‰ï¼Œé¢„è®¢çŠ¶æ€
}
```

#### QueryTimeSlotsDto
```typescript
{
  startDate?: string;  // å¯é€‰ï¼Œå¼€å§‹æ—¥æœŸèŒƒå›´
  endDate?: string;    // å¯é€‰ï¼Œç»“æŸæ—¥æœŸèŒƒå›´
  isBooked?: boolean;  // å¯é€‰ï¼Œé¢„è®¢çŠ¶æ€è¿‡æ»¤
  sortBy?: string;     // å¯é€‰ï¼Œæ’åºæ–¹å¼
}
```

#### CreateBatchTimeSlotsDto
```typescript
{
  dates: string[];     // æ—¥æœŸæ•°ç»„
  timeRanges: {        // æ—¶é—´æ®µæ•°ç»„
    startTime: string;
    endTime: string;
  }[];
}
```

---

## ä¸šåŠ¡é€»è¾‘

### ğŸ›¡ï¸ æ•°æ®éªŒè¯è§„åˆ™

#### 1. æ—¥æœŸæ—¶é—´éªŒè¯
- **æ—¥æœŸæ ¼å¼**: å¿…é¡»æ˜¯æœ‰æ•ˆçš„ ISO æ—¥æœŸå­—ç¬¦ä¸² (YYYY-MM-DD)
- **æ—¶é—´æ ¼å¼**: å¿…é¡»ç¬¦åˆ HH:MM:SS æ ¼å¼
- **è¿‡å»æ—¥æœŸ**: ä¸å…è®¸åˆ›å»ºè¿‡å»æ—¥æœŸçš„æ—¶é—´æ§½
- **æ—¶é—´é¡ºåº**: ç»“æŸæ—¶é—´å¿…é¡»æ™šäºå¼€å§‹æ—¶é—´
- **æœ€å°æ—¶é•¿**: æ—¶é—´æ§½æœ€å°‘30åˆ†é’Ÿ

#### 2. å†²çªæ£€æµ‹é€»è¾‘
```typescript
// å†²çªæ£€æµ‹ç®—æ³•
function hasConflict(existing: TimeSlot, new: CreateTimeSlotDto): boolean {
  const sameDate = existing.date.toDateString() === new Date(new.date).toDateString();
  const timeOverlap = (
    new.startTime < existing.endTime && 
    new.endTime > existing.startTime
  );
  return sameDate && timeOverlap;
}
```

#### 3. ä¸šåŠ¡è§„åˆ™
- **å”¯ä¸€æ€§**: åŒä¸€æ—¶é—´æ®µä¸èƒ½åˆ›å»ºé‡å¤çš„æ—¶é—´æ§½
- **å®Œæ•´æ€§**: å·²æœ‰è®¢å•çš„æ—¶é—´æ§½ä¸èƒ½éšæ„åˆ é™¤
- **ä¸€è‡´æ€§**: æ—¶é—´æ§½çŠ¶æ€ä¸è®¢å•çŠ¶æ€ä¿æŒåŒæ­¥
- **æœ‰æ•ˆæ€§**: æ‰€æœ‰æ—¶é—´éƒ½å¿…é¡»åœ¨å·¥ä½œå®¤è¥ä¸šæ—¶é—´å†…

### ğŸ”„ çŠ¶æ€ç®¡ç†

#### æ—¶é—´æ§½çŠ¶æ€
- **å¯ç”¨** (isBooked: false): å¯ä»¥è¢«é¢„è®¢
- **å·²é¢„è®¢** (isBooked: true): å·²è¢«è®¢å•å ç”¨

#### çŠ¶æ€è½¬æ¢
```
å¯ç”¨ â†’ å·²é¢„è®¢  (åˆ›å»ºè®¢å•æ—¶)
å·²é¢„è®¢ â†’ å¯ç”¨  (å–æ¶ˆè®¢å•æ—¶)
```

### ğŸ¯ æ‰¹é‡æ“ä½œé€»è¾‘

#### æ‰¹é‡åˆ›å»ºæµç¨‹
1. **å‚æ•°éªŒè¯**: éªŒè¯æ‰€æœ‰æ—¥æœŸå’Œæ—¶é—´æ ¼å¼
2. **ç”Ÿæˆç»„åˆ**: ç”Ÿæˆæ‰€æœ‰æ—¥æœŸå’Œæ—¶é—´æ®µçš„ç»„åˆ
3. **å†²çªæ£€æµ‹**: æ£€æŸ¥æ¯ä¸ªç»„åˆæ˜¯å¦å­˜åœ¨å†²çª
4. **äº‹åŠ¡æ‰§è¡Œ**: åœ¨æ•°æ®åº“äº‹åŠ¡ä¸­æ‰¹é‡åˆ›å»º
5. **ç»“æœç»Ÿè®¡**: è¿”å›åˆ›å»ºæˆåŠŸå’Œè·³è¿‡çš„æ•°é‡

#### é”™è¯¯å¤„ç†ç­–ç•¥
- **éƒ¨åˆ†å¤±è´¥**: æ‰¹é‡æ“ä½œä¸­éƒ¨åˆ†å¤±è´¥ä¸å½±å“å…¶ä»–æ“ä½œ
- **å…¨é‡å›æ»š**: ä¸¥é‡é”™è¯¯æ—¶å›æ»šæ•´ä¸ªäº‹åŠ¡
- **è¯¦ç»†æ—¥å¿—**: è®°å½•æ‰€æœ‰æ“ä½œç»“æœå’Œé”™è¯¯ä¿¡æ¯

---

## æŠ€æœ¯å®ç°

### ğŸ”§ æ ¸å¿ƒæŠ€æœ¯æ ˆ
- **NestJS**: Web æ¡†æ¶
- **Prisma**: ORM æ•°æ®åº“è®¿é—®
- **TypeScript**: ç±»å‹å®‰å…¨
- **class-validator**: æ•°æ®éªŒè¯
- **Swagger**: API æ–‡æ¡£

### ğŸ“‹ ä¾èµ–æ³¨å…¥
```typescript
@Injectable()
export class TimeSlotsService {
  constructor(
    private readonly prisma: PrismaService
  ) {}
}
```

### ğŸ—„ï¸ æ•°æ®åº“æ“ä½œ

#### å•ä¸ªåˆ›å»º
```typescript
async create(dto: CreateTimeSlotDto): Promise<TimeSlot> {
  return await this.prisma.timeSlot.create({
    data: {
      date: new Date(dto.date),
      startTime: new Date(`1970-01-01T${dto.startTime}Z`),
      endTime: new Date(`1970-01-01T${dto.endTime}Z`),
    },
  });
}
```

#### æ‰¹é‡åˆ›å»º
```typescript
async createBatch(dto: CreateBatchTimeSlotsDto) {
  return await this.prisma.$transaction(async (tx) => {
    const created = [];
    for (const combination of combinations) {
      try {
        const timeSlot = await tx.timeSlot.create({ data: combination });
        created.push(timeSlot);
      } catch (error) {
        // å¤„ç†å†²çªï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
      }
    }
    return { created, skipped: combinations.length - created.length };
  });
}
```

#### å…³è”æŸ¥è¯¢
```typescript
async findOne(id: number) {
  return await this.prisma.timeSlot.findUnique({
    where: { id },
    include: {
      order: {
        include: {
          user: {
            select: { id: true, name: true, phone: true }
          },
          package: {
            select: { id: true, name: true, price: true }
          }
        }
      }
    }
  });
}
```

### ğŸš¦ å¼‚å¸¸å¤„ç†

#### è‡ªå®šä¹‰å¼‚å¸¸
```typescript
// å†²çªå¼‚å¸¸
throw new ConflictException('æ—¶é—´æ§½å·²å­˜åœ¨');

// éªŒè¯å¼‚å¸¸
throw new BadRequestException('ç»“æŸæ—¶é—´å¿…é¡»æ™šäºå¼€å§‹æ—¶é—´');

// æœªæ‰¾åˆ°å¼‚å¸¸
throw new NotFoundException('æ—¶é—´æ§½ä¸å­˜åœ¨');
```

#### å¼‚å¸¸æ•è·
```typescript
try {
  return await this.prisma.timeSlot.create(data);
} catch (error) {
  if (error instanceof ConflictException) {
    throw error;
  }
  throw new BadRequestException(`åˆ›å»ºå¤±è´¥: ${error.message}`);
}
```

### ğŸ“ Swagger æ–‡æ¡£é…ç½®
```typescript
@ApiTags('æ—¶é—´æ§½ç®¡ç†')
@ApiOperation({ summary: 'åˆ›å»ºå•ä¸ªæ—¶é—´æ§½' })
@ApiResponse({ status: 201, description: 'æ—¶é—´æ§½åˆ›å»ºæˆåŠŸ' })
@ApiResponse({ status: 400, description: 'è¯·æ±‚å‚æ•°é”™è¯¯' })
@ApiResponse({ status: 409, description: 'æ—¶é—´æ§½å·²å­˜åœ¨' })
```

---

## ä½¿ç”¨ç¤ºä¾‹

### ğŸ¯ å‰ç«¯é›†æˆç¤ºä¾‹

#### React + TypeScript
```typescript
// æ—¶é—´æ§½æœåŠ¡ç±»
class TimeSlotService {
  private baseURL = '/api/time-slots';

  // è·å–å¯ç”¨æ—¶é—´æ§½
  async getAvailable(date: string): Promise<TimeSlot[]> {
    const response = await fetch(`${this.baseURL}/available?date=${date}`);
    return response.json();
  }

  // åˆ›å»ºæ—¶é—´æ§½
  async create(data: CreateTimeSlotDto): Promise<TimeSlot> {
    const response = await fetch(this.baseURL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    return response.json();
  }

  // æ‰¹é‡åˆ›å»º
  async createBatch(data: CreateBatchTimeSlotsDto) {
    const response = await fetch(`${this.baseURL}/batch`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    return response.json();
  }
}

// React ç»„ä»¶ä½¿ç”¨
function TimeSlotPicker({ selectedDate }: { selectedDate: string }) {
  const [availableSlots, setAvailableSlots] = useState<TimeSlot[]>([]);
  const timeSlotService = new TimeSlotService();

  useEffect(() => {
    if (selectedDate) {
      timeSlotService.getAvailable(selectedDate)
        .then(setAvailableSlots)
        .catch(console.error);
    }
  }, [selectedDate]);

  return (
    <div>
      {availableSlots.map(slot => (
        <button key={slot.id} onClick={() => selectSlot(slot)}>
          {formatTime(slot.startTime)} - {formatTime(slot.endTime)}
        </button>
      ))}
    </div>
  );
}
```

#### Vue 3 + Composition API
```typescript
// composables/useTimeSlots.ts
import { ref, computed } from 'vue';

export function useTimeSlots() {
  const timeSlots = ref<TimeSlot[]>([]);
  const loading = ref(false);
  const error = ref<string | null>(null);

  const availableSlots = computed(() => 
    timeSlots.value.filter(slot => !slot.isBooked)
  );

  const fetchAvailable = async (date: string) => {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await fetch(`/api/time-slots/available?date=${date}`);
      timeSlots.value = await response.json();
    } catch (err) {
      error.value = 'è·å–æ—¶é—´æ§½å¤±è´¥';
    } finally {
      loading.value = false;
    }
  };

  return {
    timeSlots,
    availableSlots,
    loading,
    error,
    fetchAvailable,
  };
}

// ç»„ä»¶ä¸­ä½¿ç”¨
<script setup lang="ts">
import { useTimeSlots } from '@/composables/useTimeSlots';

const props = defineProps<{ date: string }>();
const { availableSlots, loading, fetchAvailable } = useTimeSlots();

watch(() => props.date, (newDate) => {
  if (newDate) fetchAvailable(newDate);
}, { immediate: true });
</script>
```

### ğŸ”§ ç®¡ç†ç•Œé¢ç¤ºä¾‹

#### æ‰¹é‡åˆ›å»ºæ—¶é—´æ§½
```typescript
// ç®¡ç†å‘˜æ‰¹é‡åˆ›å»ºç»„ä»¶
function BatchCreateTimeSlots() {
  const [dates, setDates] = useState<string[]>([]);
  const [timeRanges, setTimeRanges] = useState([
    { startTime: '09:00:00', endTime: '11:00:00' },
    { startTime: '14:00:00', endTime: '16:00:00' },
  ]);

  const handleBatchCreate = async () => {
    try {
      const result = await timeSlotService.createBatch({
        dates,
        timeRanges,
      });
      
      alert(`æˆåŠŸåˆ›å»º ${result.created.length} ä¸ªæ—¶é—´æ§½ï¼Œè·³è¿‡ ${result.skipped} ä¸ª`);
    } catch (error) {
      alert('æ‰¹é‡åˆ›å»ºå¤±è´¥');
    }
  };

  return (
    <div>
      <DatePicker multiple value={dates} onChange={setDates} />
      <TimeRangeEditor ranges={timeRanges} onChange={setTimeRanges} />
      <button onClick={handleBatchCreate}>æ‰¹é‡åˆ›å»º</button>
    </div>
  );
}
```

### ğŸ“Š æ•°æ®ç»Ÿè®¡ç¤ºä¾‹

#### æ—¶é—´æ§½åˆ©ç”¨ç‡ç»Ÿè®¡
```typescript
// ç»Ÿè®¡æœåŠ¡
class TimeSlotStatsService {
  async getUtilizationRate(startDate: string, endDate: string) {
    const allSlots = await fetch(
      `/api/time-slots?startDate=${startDate}&endDate=${endDate}`
    ).then(r => r.json());
    
    const bookedSlots = allSlots.filter(slot => slot.isBooked);
    
    return {
      total: allSlots.length,
      booked: bookedSlots.length,
      available: allSlots.length - bookedSlots.length,
      utilizationRate: (bookedSlots.length / allSlots.length * 100).toFixed(2),
    };
  }
}

// ç»Ÿè®¡ç»„ä»¶
function TimeSlotStats() {
  const [stats, setStats] = useState(null);
  const [dateRange, setDateRange] = useState({
    start: format(startOfWeek(new Date()), 'yyyy-MM-dd'),
    end: format(endOfWeek(new Date()), 'yyyy-MM-dd'),
  });

  useEffect(() => {
    const statsService = new TimeSlotStatsService();
    statsService.getUtilizationRate(dateRange.start, dateRange.end)
      .then(setStats);
  }, [dateRange]);

  return (
    <div>
      <h3>æ—¶é—´æ§½åˆ©ç”¨ç‡ç»Ÿè®¡</h3>
      {stats && (
        <div>
          <p>æ€»æ—¶é—´æ§½: {stats.total}</p>
          <p>å·²é¢„è®¢: {stats.booked}</p>
          <p>å¯ç”¨: {stats.available}</p>
          <p>åˆ©ç”¨ç‡: {stats.utilizationRate}%</p>
        </div>
      )}
    </div>
  );
}
```

---

## éƒ¨ç½²å’Œè¿ç»´

### ğŸš€ éƒ¨ç½²é…ç½®

#### Docker é…ç½®
```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["npm", "run", "start:prod"]
```

#### ç¯å¢ƒå˜é‡
```env
# æ•°æ®åº“é…ç½®
DATABASE_URL="postgresql://user:password@localhost:5432/baby_photo"

# åº”ç”¨é…ç½®
NODE_ENV=production
PORT=3000

# æ—¶é—´æ§½é…ç½®
MIN_SLOT_DURATION_MINUTES=30
MAX_ADVANCE_BOOKING_DAYS=90
BUSINESS_HOURS_START=09:00
BUSINESS_HOURS_END=18:00
```

### ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

#### æ€§èƒ½ç›‘æ§
```typescript
// æ€§èƒ½ç›‘æ§è£…é¥°å™¨
@Injectable()
export class PerformanceInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const start = Date.now();
    
    return next.handle().pipe(
      tap(() => {
        const duration = Date.now() - start;
        const request = context.switchToHttp().getRequest();
        console.log(`${request.method} ${request.url} - ${duration}ms`);
      }),
    );
  }
}
```

#### é”™è¯¯æ—¥å¿—
```typescript
// å…¨å±€å¼‚å¸¸è¿‡æ»¤å™¨
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const request = ctx.getRequest();
    const response = ctx.getResponse();

    // è®°å½•é”™è¯¯æ—¥å¿—
    console.error({
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      error: exception,
    });

    // è¿”å›é”™è¯¯å“åº”
    response.status(500).json({
      statusCode: 500,
      timestamp: new Date().toISOString(),
      path: request.url,
      message: 'Internal server error',
    });
  }
}
```

### ğŸ”§ è¿ç»´è„šæœ¬

#### æ•°æ®åº“å¤‡ä»½
```bash
#!/bin/bash
# backup-timeslots.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backup/timeslots"
DB_NAME="baby_photo"

# åˆ›å»ºå¤‡ä»½ç›®å½•
mkdir -p $BACKUP_DIR

# å¤‡ä»½æ—¶é—´æ§½ç›¸å…³è¡¨
pg_dump -h localhost -U postgres -t time_slots -t orders $DB_NAME > $BACKUP_DIR/timeslots_$DATE.sql

# ä¿ç•™æœ€è¿‘30å¤©çš„å¤‡ä»½
find $BACKUP_DIR -name "timeslots_*.sql" -mtime +30 -delete

echo "å¤‡ä»½å®Œæˆ: timeslots_$DATE.sql"
```

#### æ•°æ®æ¸…ç†
```bash
#!/bin/bash
# cleanup-old-timeslots.sh

# åˆ é™¤90å¤©å‰çš„æœªé¢„è®¢æ—¶é—´æ§½
psql -h localhost -U postgres -d baby_photo -c "
DELETE FROM time_slots 
WHERE is_booked = false 
AND date < CURRENT_DATE - INTERVAL '90 days';"

echo "æ¸…ç†å®Œæˆ"
```

### ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

#### æ•°æ®åº“ç´¢å¼•
```sql
-- ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½çš„ç´¢å¼•
CREATE INDEX idx_time_slots_date ON time_slots(date);
CREATE INDEX idx_time_slots_booked ON time_slots(is_booked);
CREATE INDEX idx_time_slots_date_time ON time_slots(date, start_time);
CREATE INDEX idx_time_slots_available ON time_slots(date, is_booked) WHERE is_booked = false;
```

#### ç¼“å­˜ç­–ç•¥
```typescript
// Redis ç¼“å­˜è£…é¥°å™¨
@Injectable()
export class CacheService {
  constructor(private redis: Redis) {}

  async getAvailableSlots(date: string): Promise<TimeSlot[]> {
    const cacheKey = `available_slots:${date}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const slots = await this.timeSlotsService.findAvailable(date);
    await this.redis.setex(cacheKey, 300, JSON.stringify(slots)); // 5åˆ†é’Ÿç¼“å­˜
    
    return slots;
  }
}
```

---

## å¸¸è§é—®é¢˜

### â“ FAQ

#### Q1: å¦‚ä½•å¤„ç†æ—¶åŒºé—®é¢˜ï¼Ÿ
**A**: ç³»ç»Ÿç»Ÿä¸€ä½¿ç”¨ UTC æ—¶é—´å­˜å‚¨ï¼Œå‰ç«¯æ ¹æ®ç”¨æˆ·æ—¶åŒºè¿›è¡Œæ˜¾ç¤ºè½¬æ¢ã€‚

```typescript
// æ—¶åŒºè½¬æ¢ç¤ºä¾‹
function convertToUserTimezone(utcTime: string, timezone: string): string {
  return new Intl.DateTimeFormat('zh-CN', {
    timeZone: timezone,
    hour: '2-digit',
    minute: '2-digit',
  }).format(new Date(utcTime));
}
```

#### Q2: æ‰¹é‡åˆ›å»ºæ—¶å¦‚ä½•å¤„ç†éƒ¨åˆ†å¤±è´¥ï¼Ÿ
**A**: ç³»ç»Ÿé‡‡ç”¨"å°½åŠ›è€Œä¸º"ç­–ç•¥ï¼ŒæˆåŠŸåˆ›å»ºå¯èƒ½çš„æ—¶é—´æ§½ï¼Œè·³è¿‡å†²çªçš„ï¼Œè¿”å›è¯¦ç»†ç»“æœã€‚

```typescript
// æ‰¹é‡åˆ›å»ºç»“æœ
interface BatchCreateResult {
  created: TimeSlot[];     // æˆåŠŸåˆ›å»ºçš„
  skipped: number;         // è·³è¿‡çš„æ•°é‡
  total: number;           // æ€»å…±å°è¯•åˆ›å»ºçš„æ•°é‡
  errors?: string[];       // é”™è¯¯ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
}
```

#### Q3: å¦‚ä½•é˜²æ­¢å¹¶å‘é¢„è®¢å†²çªï¼Ÿ
**A**: ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡å’Œå”¯ä¸€ç´¢å¼•çº¦æŸé˜²æ­¢å¹¶å‘é—®é¢˜ã€‚

```typescript
// åŸå­æ€§é¢„è®¢æ“ä½œ
async bookTimeSlot(timeSlotId: number, orderId: number) {
  return await this.prisma.$transaction(async (tx) => {
    // æ£€æŸ¥æ—¶é—´æ§½æ˜¯å¦å¯ç”¨
    const timeSlot = await tx.timeSlot.findUnique({
      where: { id: timeSlotId, isBooked: false }
    });
    
    if (!timeSlot) {
      throw new ConflictException('æ—¶é—´æ§½å·²è¢«é¢„è®¢');
    }
    
    // åŸå­æ€§æ›´æ–°
    return await tx.timeSlot.update({
      where: { id: timeSlotId },
      data: { isBooked: true }
    });
  });
}
```

#### Q4: å¦‚ä½•å®ç°æ—¶é—´æ§½çš„è½¯åˆ é™¤ï¼Ÿ
**A**: æ·»åŠ  `deletedAt` å­—æ®µå®ç°è½¯åˆ é™¤ï¼Œä¿ç•™å†å²æ•°æ®ã€‚

```typescript
// Prisma æ¨¡å‹æ‰©å±•
model TimeSlot {
  id        Int       @id @default(autoincrement())
  date      DateTime
  startTime DateTime
  endTime   DateTime
  isBooked  Boolean   @default(false)
  deletedAt DateTime? // è½¯åˆ é™¤å­—æ®µ
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

// è½¯åˆ é™¤å®ç°
async softDelete(id: number) {
  return await this.prisma.timeSlot.update({
    where: { id },
    data: { deletedAt: new Date() }
  });
}
```

#### Q5: å¦‚ä½•å¤„ç†èŠ‚å‡æ—¥å’Œç‰¹æ®Šè¥ä¸šæ—¶é—´ï¼Ÿ
**A**: å¯ä»¥æ‰©å±•æ¨¡å‹æ·»åŠ ç‰¹æ®Šè§„åˆ™è¡¨ã€‚

```typescript
// ç‰¹æ®Šè¥ä¸šæ—¶é—´æ¨¡å‹
model SpecialBusinessHours {
  id          Int      @id @default(autoincrement())
  date        DateTime @unique
  isClosed    Boolean  @default(false)
  startTime   DateTime?
  endTime     DateTime?
  description String?
}

// æ£€æŸ¥ç‰¹æ®Šè¥ä¸šæ—¶é—´
async isValidBusinessTime(date: string, startTime: string, endTime: string): Promise<boolean> {
  const specialHours = await this.prisma.specialBusinessHours.findUnique({
    where: { date: new Date(date) }
  });
  
  if (specialHours?.isClosed) {
    return false;
  }
  
  // å…¶ä»–ä¸šåŠ¡é€»è¾‘...
  return true;
}
```

### ğŸ› æ•…éšœæ’é™¤

#### å¸¸è§é”™è¯¯åŠè§£å†³æ–¹æ¡ˆ

1. **æ—¶é—´æ ¼å¼é”™è¯¯**
   ```
   é”™è¯¯: æ—¶é—´æ ¼å¼å¿…é¡»ä¸º HH:MM:SS
   è§£å†³: ç¡®ä¿æ—¶é—´å­—ç¬¦ä¸²ç¬¦åˆ "09:00:00" æ ¼å¼
   ```

2. **æ—¶é—´æ§½å†²çª**
   ```
   é”™è¯¯: æ—¶é—´æ§½å·²å­˜åœ¨
   è§£å†³: æ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒæ—¶é—´æ®µçš„æ—¶é—´æ§½ï¼Œè°ƒæ•´æ—¶é—´æˆ–é€‰æ‹©å…¶ä»–æ—¥æœŸ
   ```

3. **æ•°æ®åº“è¿æ¥å¤±è´¥**
   ```
   é”™è¯¯: Can't reach database server
   è§£å†³: æ£€æŸ¥æ•°æ®åº“æœåŠ¡çŠ¶æ€å’Œè¿æ¥é…ç½®
   ```

4. **å†…å­˜æº¢å‡ºï¼ˆæ‰¹é‡æ“ä½œï¼‰**
   ```
   é”™è¯¯: JavaScript heap out of memory
   è§£å†³: å‡å°‘æ‰¹é‡æ“ä½œçš„æ•°æ®é‡ï¼Œåˆ†æ‰¹å¤„ç†
   ```

### ğŸ“ æŠ€æœ¯æ”¯æŒ

- **æ–‡æ¡£æ›´æ–°**: å®šæœŸç»´æŠ¤å’Œæ›´æ–°æœ¬æ–‡æ¡£
- **é—®é¢˜åé¦ˆ**: é€šè¿‡ GitHub Issues æäº¤é—®é¢˜
- **æŠ€æœ¯è®¨è®º**: å‚ä¸å›¢é˜ŸæŠ€æœ¯ä¼šè®®
- **ä»£ç å®¡æŸ¥**: éµå¾ªä»£ç å®¡æŸ¥æµç¨‹

---

## æ€»ç»“

æ—¶é—´æ§½åŠŸèƒ½æ¨¡å—æ˜¯ä¸€ä¸ªå®Œæ•´ã€å¥å£®çš„é¢„çº¦ç®¡ç†ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶ã€‚å®ƒæä¾›äº†ï¼š

âœ… **å®Œæ•´çš„åŠŸèƒ½è¦†ç›–**: ä»åˆ›å»ºåˆ°åˆ é™¤çš„å…¨ç”Ÿå‘½å‘¨æœŸç®¡ç†  
âœ… **å¼ºå¤§çš„ä¸šåŠ¡é€»è¾‘**: æ™ºèƒ½å†²çªæ£€æµ‹å’Œæ•°æ®éªŒè¯  
âœ… **ä¼˜ç§€çš„æ‰©å±•æ€§**: æ¨¡å—åŒ–è®¾è®¡ä¾¿äºåŠŸèƒ½æ‰©å±•  
âœ… **è‰¯å¥½çš„æ€§èƒ½**: æ•°æ®åº“ä¼˜åŒ–å’Œç¼“å­˜ç­–ç•¥  
âœ… **è¯¦ç»†çš„æ–‡æ¡£**: å®Œæ•´çš„APIæ–‡æ¡£å’Œä½¿ç”¨ç¤ºä¾‹  
âœ… **ç”Ÿäº§å°±ç»ª**: é”™è¯¯å¤„ç†ã€ç›‘æ§å’Œè¿ç»´æ”¯æŒ  

è¯¥æ¨¡å—éµå¾ªæœ€ä½³å®è·µï¼Œä¸ºå©´å„¿æ‘„å½±å·¥ä½œå®¤æä¾›äº†ä¸“ä¸šã€å¯é çš„é¢„çº¦ç®¡ç†è§£å†³æ–¹æ¡ˆã€‚

---

*æ–‡æ¡£ç‰ˆæœ¬: 1.0.0*  
*æœ€åæ›´æ–°: 2024å¹´7æœˆ25æ—¥*  
*ç»´æŠ¤è€…: å¼€å‘å›¢é˜Ÿ*

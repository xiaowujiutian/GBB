# ğŸ“‹ è®¢å•æ¨¡å—åŠŸèƒ½è¯´æ˜æ–‡æ¡£

## ç›®å½•
- [æ¨¡å—æ¦‚è¿°](#æ¨¡å—æ¦‚è¿°)
- [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
- [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
- [API æ¥å£è¯¦æƒ…](#api-æ¥å£è¯¦æƒ…)
- [API æµ‹è¯•å‚æ•°ç¤ºä¾‹](#api-æµ‹è¯•å‚æ•°ç¤ºä¾‹)
- [æ•°æ®æ¨¡å‹](#æ•°æ®æ¨¡å‹)
- [ä¸šåŠ¡é€»è¾‘](#ä¸šåŠ¡é€»è¾‘)
- [çŠ¶æ€ç®¡ç†](#çŠ¶æ€ç®¡ç†)
- [æŠ€æœ¯å®ç°](#æŠ€æœ¯å®ç°)
- [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
- [è®¢å•å¤„ç†æµç¨‹](#è®¢å•å¤„ç†æµç¨‹)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

---

## æ¨¡å—æ¦‚è¿°

### ğŸ¯ åŠŸèƒ½å®šä½
è®¢å•æ¨¡å—æ˜¯å©´å„¿æ‘„å½±å·¥ä½œå®¤ç³»ç»Ÿçš„æ ¸å¿ƒä¸šåŠ¡æ¨¡å—ï¼Œè´Ÿè´£ç®¡ç†æ•´ä¸ªé¢„çº¦å’ŒæœåŠ¡æµç¨‹ã€‚è¯¥æ¨¡å—è¿æ¥ç”¨æˆ·ã€å¥—é¤ã€æ—¶é—´æ§½å’Œæ”¯ä»˜ç­‰å…¶ä»–æ¨¡å—ï¼Œå®ç°å®Œæ•´çš„è®¢å•ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œæ˜¯æ•´ä¸ªä¸šåŠ¡æµç¨‹çš„ä¸­æ¢ç³»ç»Ÿã€‚

### ğŸš€ ä¸»è¦ç‰¹æ€§
- **å®Œæ•´çš„è®¢å•ç®¡ç†**: åˆ›å»ºã€æŸ¥è¯¢ã€æ›´æ–°ã€å–æ¶ˆè®¢å•
- **æ™ºèƒ½æ—¶é—´æ§½ç®¡ç†**: è‡ªåŠ¨å¤„ç†æ—¶é—´æ§½é¢„è®¢å’Œé‡Šæ”¾
- **å¤šç»´åº¦æŸ¥è¯¢**: æ”¯æŒæŒ‰ç”¨æˆ·ã€è®¢å•å·ã€çŠ¶æ€ç­‰å¤šç§æ–¹å¼æŸ¥è¯¢
- **çŠ¶æ€æµè½¬æ§åˆ¶**: ä¸¥æ ¼çš„è®¢å•çŠ¶æ€ç®¡ç†å’Œæµè½¬æ§åˆ¶
- **å…³è”æ•°æ®å¤„ç†**: å®Œæ•´çš„ç”¨æˆ·ã€å¥—é¤ã€æ—¶é—´æ§½ã€æ”¯ä»˜å…³è”
- **ä¸šåŠ¡è§„åˆ™ä¿æŠ¤**: å®Œå–„çš„ä¸šåŠ¡é€»è¾‘éªŒè¯å’Œæ•°æ®å®Œæ•´æ€§ä¿æŠ¤

### ğŸ“Š ä¸šåŠ¡ä»·å€¼
- ç»Ÿä¸€ç®¡ç†æ‰€æœ‰é¢„çº¦å’ŒæœåŠ¡è®¢å•
- æä¾›å®Œæ•´çš„å®¢æˆ·æœåŠ¡æµç¨‹è·Ÿè¸ª
- æ”¯æŒç²¾ç»†åŒ–çš„è®¢å•çŠ¶æ€ç®¡ç†
- ä¾¿äºå®¢æœå’Œè¿è¥å›¢é˜Ÿè¿›è¡Œè®¢å•å¤„ç†
- ä¸ºè´¢åŠ¡å’Œç»Ÿè®¡åˆ†ææä¾›æ•°æ®åŸºç¡€

---

## ç³»ç»Ÿæ¶æ„

### ğŸ—ï¸ æ¨¡å—ç»“æ„
```
src/modules/orders/
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-order.dto.ts     # åˆ›å»ºè®¢å•DTO
â”‚   â”œâ”€â”€ update-order.dto.ts     # æ›´æ–°è®¢å•DTO
â”‚   â””â”€â”€ create-payment.dto.ts   # åˆ›å»ºæ”¯ä»˜DTOï¼ˆå…³è”ä½¿ç”¨ï¼‰
â”œâ”€â”€ orders.controller.ts        # è®¢å•æ§åˆ¶å™¨
â”œâ”€â”€ orders.service.ts           # è®¢å•æœåŠ¡
â””â”€â”€ orders.module.ts            # è®¢å•æ¨¡å—
```

### ğŸ”„ æ¶æ„å±‚æ¬¡
1. **æ§åˆ¶å™¨å±‚**: å¤„ç†HTTPè¯·æ±‚ï¼Œå‚æ•°éªŒè¯ï¼Œå“åº”æ ¼å¼åŒ–
2. **æœåŠ¡å±‚**: æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼ŒçŠ¶æ€ç®¡ç†ï¼Œäº‹åŠ¡å¤„ç†
3. **æ•°æ®è®¿é—®å±‚**: é€šè¿‡Prismaè¿›è¡Œå¤æ‚çš„å…³è”æŸ¥è¯¢å’Œäº‹åŠ¡æ“ä½œ
4. **DTOå±‚**: æ•°æ®ä¼ è¾“å¯¹è±¡ï¼Œç¡®ä¿ç±»å‹å®‰å…¨å’ŒéªŒè¯

### ğŸ”— ä¾èµ–å…³ç³»
- **PrismaModule**: æ•°æ®åº“è®¿é—®æœåŠ¡
- **UsersModule**: ç”¨æˆ·ä¿¡æ¯å…³è”
- **PackagesModule**: å¥—é¤ä¿¡æ¯å…³è”
- **TimeSlotsModule**: æ—¶é—´æ§½ç®¡ç†ï¼ˆéšå¼ä¾èµ–ï¼‰
- **PaymentsModule**: æ”¯ä»˜ä¿¡æ¯å…³è”ï¼ˆéšå¼ä¾èµ–ï¼‰

---

## æ ¸å¿ƒåŠŸèƒ½

### 1. è®¢å•åˆ›å»º
**åŠŸèƒ½æè¿°**: åˆ›å»ºæ–°è®¢å•ï¼Œå…³è”ç”¨æˆ·ã€å¥—é¤å’Œæ—¶é—´æ§½
- ç”¨æˆ·ä¿¡æ¯éªŒè¯å’Œå…³è”
- å¥—é¤æœ‰æ•ˆæ€§æ£€æŸ¥
- æ—¶é—´æ§½å¯ç”¨æ€§éªŒè¯å’Œé¢„è®¢
- è®¢å•å·è‡ªåŠ¨ç”Ÿæˆ
- åˆå§‹çŠ¶æ€è®¾ç½®å’Œæ•°æ®å®Œæ•´æ€§ä¿æŠ¤

### 2. è®¢å•æŸ¥è¯¢
**å…¨é‡æŸ¥è¯¢**: è·å–æ‰€æœ‰è®¢å•ï¼Œæ”¯æŒç®¡ç†åå°
**ç”¨æˆ·æŸ¥è¯¢**: æ ¹æ®ç”¨æˆ·IDæŸ¥è¯¢ç”¨æˆ·çš„æ‰€æœ‰è®¢å•
**è®¢å•å·æŸ¥è¯¢**: æ ¹æ®è®¢å•å·å¿«é€Ÿå®šä½è®¢å•
**å•ä¸ªæŸ¥è¯¢**: æ ¹æ®è®¢å•IDè·å–è¯¦ç»†ä¿¡æ¯
**å…³è”æŸ¥è¯¢**: åŒ…å«ç”¨æˆ·ã€å¥—é¤ã€æ—¶é—´æ§½ã€æ”¯ä»˜ç­‰å®Œæ•´ä¿¡æ¯

### 3. è®¢å•æ›´æ–°
**çŠ¶æ€æ›´æ–°**: æ”¯æŒè®¢å•çŠ¶æ€æµè½¬ï¼ˆå¾…æ”¯ä»˜â†’å·²æ”¯ä»˜â†’å·²å®Œæˆç­‰ï¼‰
**æ—¶é—´æ§½å˜æ›´**: æ™ºèƒ½å¤„ç†æ—¶é—´æ§½çš„é‡Šæ”¾å’Œé‡æ–°é¢„è®¢
**ä¿¡æ¯ä¿®æ”¹**: æ”¯æŒè®¢å•å¤‡æ³¨ã€è”ç³»æ–¹å¼ç­‰ä¿¡æ¯æ›´æ–°
**å…³è”æ•°æ®åŒæ­¥**: ç¡®ä¿ç›¸å…³æ•°æ®çš„ä¸€è‡´æ€§

### 4. è®¢å•ç®¡ç†
**å–æ¶ˆè®¢å•**: å¤„ç†è®¢å•å–æ¶ˆï¼Œé‡Šæ”¾æ—¶é—´æ§½ï¼Œå¤„ç†é€€æ¬¾
**å®Œæˆè®¢å•**: æ ‡è®°è®¢å•å®Œæˆï¼Œæ›´æ–°ç›¸å…³çŠ¶æ€
**å¼‚å¸¸å¤„ç†**: å¤„ç†å„ç§å¼‚å¸¸æƒ…å†µå’Œæ•°æ®æ¢å¤

---

## API æ¥å£è¯¦æƒ…

### ğŸ“‹ æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | åŠŸèƒ½ | çŠ¶æ€ç  |
|------|------|------|--------|
| POST | `/orders` | åˆ›å»ºè®¢å• | 201, 400, 409 |
| GET | `/orders` | è·å–æ‰€æœ‰è®¢å• | 200, 500 |
| GET | `/orders/user/:userId` | æ ¹æ®ç”¨æˆ·IDè·å–è®¢å• | 200, 404 |
| GET | `/orders/order-no/:orderNo` | æ ¹æ®è®¢å•å·è·å–è®¢å• | 200, 404 |
| GET | `/orders/:id` | è·å–è®¢å•è¯¦æƒ… | 200, 404 |
| PATCH | `/orders/:id` | æ›´æ–°è®¢å•ä¿¡æ¯ | 200, 400, 404 |

### ğŸ” æ¥å£è¯¦ç»†è¯´æ˜

#### 1. åˆ›å»ºè®¢å•
```http
POST /orders
Content-Type: application/json

{
  "userId": 1,
  "packageId": 1,
  "timeSlotId": 5,
  "contactPhone": "13800138000",
  "notes": "å¸Œæœ›æ‹æ‘„æ¸©é¦¨çš„äº²å­ç…§ç‰‡"
}
```

**è¯·æ±‚å‚æ•°**:
- `userId` (å¿…å¡«): ç”¨æˆ·ID
- `packageId` (å¿…å¡«): å¥—é¤ID
- `timeSlotId` (å¿…å¡«): æ—¶é—´æ§½ID
- `contactPhone` (å¿…å¡«): è”ç³»ç”µè¯
- `notes` (å¯é€‰): è®¢å•å¤‡æ³¨

**å“åº”ç¤ºä¾‹**:
```json
{
  "id": 1,
  "orderNo": "ORD20240725001",
  "userId": 1,
  "packageId": 1,
  "timeSlotId": 5,
  "contactPhone": "13800138000",
  "notes": "å¸Œæœ›æ‹æ‘„æ¸©é¦¨çš„äº²å­ç…§ç‰‡",
  "status": "PENDING",
  "paymentStatus": "PENDING",
  "totalAmount": 899.00,
  "createdAt": "2024-07-25T10:30:00.000Z",
  "updatedAt": "2024-07-25T10:30:00.000Z",
  "user": {
    "id": 1,
    "nickname": "å°å®è´å¦ˆå¦ˆ",
    "phone": "13800138000"
  },
  "package": {
    "id": 1,
    "name": "ç»å…¸äº²å­æ‘„å½±å¥—é¤",
    "price": 899.00,
    "duration": 120
  },
  "timeSlot": {
    "id": 5,
    "date": "2024-08-15T00:00:00.000Z",
    "startTime": "1970-01-01T09:00:00.000Z",
    "endTime": "1970-01-01T11:00:00.000Z",
    "isBooked": true
  }
}
```

#### 2. è·å–æ‰€æœ‰è®¢å•
```http
GET /orders
```

**å“åº”ç¤ºä¾‹**:
```json
[
  {
    "id": 1,
    "orderNo": "ORD20240725001",
    "userId": 1,
    "packageId": 1,
    "timeSlotId": 5,
    "contactPhone": "13800138000",
    "notes": "å¸Œæœ›æ‹æ‘„æ¸©é¦¨çš„äº²å­ç…§ç‰‡",
    "status": "PENDING",
    "paymentStatus": "PENDING",
    "totalAmount": 899.00,
    "createdAt": "2024-07-25T10:30:00.000Z",
    "updatedAt": "2024-07-25T10:30:00.000Z",
    "user": {
      "id": 1,
      "nickname": "å°å®è´å¦ˆå¦ˆ",
      "phone": "13800138000"
    },
    "package": {
      "id": 1,
      "name": "ç»å…¸äº²å­æ‘„å½±å¥—é¤",
      "price": 899.00
    },
    "timeSlot": {
      "id": 5,
      "date": "2024-08-15T00:00:00.000Z",
      "startTime": "1970-01-01T09:00:00.000Z",
      "endTime": "1970-01-01T11:00:00.000Z"
    }
  }
]
```

#### 3. æ ¹æ®ç”¨æˆ·IDè·å–è®¢å•
```http
GET /orders/user/1
```

**å“åº”ç¤ºä¾‹**: ä¸è·å–æ‰€æœ‰è®¢å•ç›¸åŒçš„æ•°æ®ç»“æ„ï¼Œä½†åªåŒ…å«è¯¥ç”¨æˆ·çš„è®¢å•

#### 4. æ ¹æ®è®¢å•å·è·å–è®¢å•
```http
GET /orders/order-no/ORD20240725001
```

**å“åº”ç¤ºä¾‹**: å•ä¸ªè®¢å•çš„è¯¦ç»†ä¿¡æ¯

#### 5. æ›´æ–°è®¢å•ä¿¡æ¯
```http
PATCH /orders/1
Content-Type: application/json

{
  "status": "CONFIRMED",
  "timeSlotId": 8,
  "notes": "æ›´æ–°å¤‡æ³¨ï¼šå®¢æˆ·è¦æ±‚æ›´æ¢æ‹æ‘„æ—¶é—´"
}
```

**æ”¯æŒæ›´æ–°çš„å­—æ®µ**:
- `status`: è®¢å•çŠ¶æ€
- `paymentStatus`: æ”¯ä»˜çŠ¶æ€
- `timeSlotId`: æ—¶é—´æ§½IDï¼ˆä¼šè‡ªåŠ¨å¤„ç†æ—¶é—´æ§½å˜æ›´ï¼‰
- `contactPhone`: è”ç³»ç”µè¯
- `notes`: è®¢å•å¤‡æ³¨

**å“åº”ç¤ºä¾‹**: è¿”å›æ›´æ–°åçš„å®Œæ•´è®¢å•ä¿¡æ¯

### ğŸ§ª API æµ‹è¯•å‚æ•°ç¤ºä¾‹

æœ¬éƒ¨åˆ†æä¾›äº†å¯åœ¨ Swagger UI (`/api/docs`) ä¸­ç›´æ¥ä½¿ç”¨çš„æµ‹è¯•å‚æ•°ã€‚

**æ³¨æ„**: åœ¨æµ‹è¯•å‰ï¼Œè¯·ç¡®ä¿æ•°æ®åº“ä¸­å­˜åœ¨æœ‰æ•ˆçš„ç”¨æˆ·ã€å¥—é¤å’Œæ—¶é—´æ§½è®°å½•ã€‚ä»¥ä¸‹ç¤ºä¾‹å‡è®¾ `userId: 1`, `packageId: 1`, `timeSlotId: 5` æ˜¯æœ‰æ•ˆçš„ã€‚

#### 1. åˆ›å»ºè®¢å• (POST /orders)

**è¯·æ±‚ä½“ç¤ºä¾‹:**
```json
{
  "userId": 1,
  "packageId": 1,
  "timeSlotId": 5,
  "contactPhone": "13912345678",
  "notes": "å®å®å¯¹é—ªå…‰ç¯æ•æ„Ÿï¼Œè¯·æ³¨æ„ã€‚"
}
```

#### 2. è·å–æ‰€æœ‰è®¢å• (GET /orders)

æ­¤æ¥å£æ— éœ€å‚æ•°ã€‚

#### 3. æ ¹æ®ç”¨æˆ·IDè·å–è®¢å• (GET /orders/user/:userId)

- **userId**: `1`

#### 4. æ ¹æ®è®¢å•å·è·å–è®¢å• (GET /orders/order-no/:orderNo)

- **orderNo**: `ORD20240725001` (è¯·ä½¿ç”¨ä¸€ä¸ªå·²å­˜åœ¨çš„è®¢å•å·)

#### 5. è·å–è®¢å•è¯¦æƒ… (GET /orders/:id)

- **id**: `1` (è¯·ä½¿ç”¨ä¸€ä¸ªå·²å­˜åœ¨çš„è®¢å•ID)

#### 6. æ›´æ–°è®¢å•ä¿¡æ¯ (PATCH /orders/:id)

- **id**: `1` (è¯·ä½¿ç”¨ä¸€ä¸ªå·²å­˜åœ¨çš„è®¢å•ID)

**è¯·æ±‚ä½“ç¤ºä¾‹1: æ›´æ–°çŠ¶æ€**
```json
{
  "status": "CONFIRMED"
}
```

**è¯·æ±‚ä½“ç¤ºä¾‹2: æ›´æ–°å¤‡æ³¨å’Œè”ç³»ç”µè¯**
```json
{
  "contactPhone": "13888888888",
  "notes": "å®¢æˆ·å·²ç¡®è®¤ï¼Œå‡†å¤‡æ‹æ‘„ã€‚"
}
```

---

## æ•°æ®æ¨¡å‹

### ğŸ“Š è®¢å•æ•°æ®ç»“æ„
```typescript
interface Order {
  id: number;            // ä¸»é”®ID
  orderNo: string;       // è®¢å•å·
  userId: number;        // ç”¨æˆ·ID
  packageId: number;     // å¥—é¤ID
  timeSlotId: number;    // æ—¶é—´æ§½ID
  contactPhone: string;  // è”ç³»ç”µè¯
  notes?: string;        // è®¢å•å¤‡æ³¨
  status: OrderStatus;   // è®¢å•çŠ¶æ€
  paymentStatus: PaymentStatus; // æ”¯ä»˜çŠ¶æ€
  totalAmount: number;   // è®¢å•æ€»é‡‘é¢
  createdAt: Date;       // åˆ›å»ºæ—¶é—´
  updatedAt: Date;       // æ›´æ–°æ—¶é—´
  
  // å…³è”å…³ç³»
  user: User;            // å…³è”ç”¨æˆ·
  package: Package;      // å…³è”å¥—é¤
  timeSlot: TimeSlot;    // å…³è”æ—¶é—´æ§½
  payments?: Payment[];  // å…³è”æ”¯ä»˜è®°å½•
}
```

### ğŸ”— å…³è”å…³ç³»
- **å¤šå¯¹ä¸€**: Order â†’ User (å¤šä¸ªè®¢å•å±äºä¸€ä¸ªç”¨æˆ·)
- **å¤šå¯¹ä¸€**: Order â†’ Package (å¤šä¸ªè®¢å•å¯ä»¥é€‰æ‹©åŒä¸€ä¸ªå¥—é¤)
- **ä¸€å¯¹ä¸€**: Order â†’ TimeSlot (ä¸€ä¸ªè®¢å•å¯¹åº”ä¸€ä¸ªæ—¶é—´æ§½)
- **ä¸€å¯¹å¤š**: Order â†’ Payment (ä¸€ä¸ªè®¢å•å¯ä»¥æœ‰å¤šæ¬¡æ”¯ä»˜è®°å½•)

### ğŸ“ DTO ç»“æ„

#### CreateOrderDto
```typescript
{
  userId: number;        // å¿…å¡«ï¼Œç”¨æˆ·ID
  packageId: number;     // å¿…å¡«ï¼Œå¥—é¤ID
  timeSlotId: number;    // å¿…å¡«ï¼Œæ—¶é—´æ§½ID
  contactPhone: string;  // å¿…å¡«ï¼Œè”ç³»ç”µè¯
  notes?: string;        // å¯é€‰ï¼Œè®¢å•å¤‡æ³¨
}
```

#### UpdateOrderDto
```typescript
{
  status?: OrderStatus;       // å¯é€‰ï¼Œè®¢å•çŠ¶æ€
  paymentStatus?: PaymentStatus; // å¯é€‰ï¼Œæ”¯ä»˜çŠ¶æ€
  timeSlotId?: number;       // å¯é€‰ï¼Œæ—¶é—´æ§½ID
  contactPhone?: string;     // å¯é€‰ï¼Œè”ç³»ç”µè¯
  notes?: string;           // å¯é€‰ï¼Œè®¢å•å¤‡æ³¨
}
```

---

## ä¸šåŠ¡é€»è¾‘

### ğŸ›¡ï¸ æ•°æ®éªŒè¯è§„åˆ™

#### 1. åˆ›å»ºè®¢å•éªŒè¯
- **userId**: å¿…å¡«ï¼Œå¿…é¡»æ˜¯æœ‰æ•ˆçš„ç”¨æˆ·ID
- **packageId**: å¿…å¡«ï¼Œå¿…é¡»æ˜¯æœ‰æ•ˆä¸”æ¿€æ´»çš„å¥—é¤ID
- **timeSlotId**: å¿…å¡«ï¼Œå¿…é¡»æ˜¯æœ‰æ•ˆä¸”æœªè¢«é¢„è®¢çš„æ—¶é—´æ§½ID
- **contactPhone**: å¿…å¡«ï¼Œå­—ç¬¦ä¸²ç±»å‹ï¼Œå»ºè®®æ‰‹æœºå·æ ¼å¼éªŒè¯
- **notes**: å¯é€‰ï¼Œå­—ç¬¦ä¸²ç±»å‹ï¼Œé•¿åº¦é™åˆ¶

#### 2. æ›´æ–°è®¢å•éªŒè¯
- **çŠ¶æ€è½¬æ¢**: å¿…é¡»ç¬¦åˆé¢„å®šä¹‰çš„çŠ¶æ€æµè½¬è§„åˆ™
- **æ—¶é—´æ§½å˜æ›´**: æ–°æ—¶é—´æ§½å¿…é¡»å¯ç”¨ï¼Œè‡ªåŠ¨å¤„ç†æ—§æ—¶é—´æ§½é‡Šæ”¾
- **å…³è”æ£€æŸ¥**: ç¡®ä¿å…³è”çš„ç”¨æˆ·ã€å¥—é¤ç­‰æ•°æ®æœ‰æ•ˆ

#### 3. ä¸šåŠ¡è§„åˆ™
- **å”¯ä¸€æ€§**: è®¢å•å·åœ¨ç³»ç»Ÿä¸­å¿…é¡»å”¯ä¸€
- **å®Œæ•´æ€§**: è®¢å•å¿…é¡»å…³è”æœ‰æ•ˆçš„ç”¨æˆ·ã€å¥—é¤å’Œæ—¶é—´æ§½
- **ä¸€è‡´æ€§**: è®¢å•çŠ¶æ€ä¸æ”¯ä»˜çŠ¶æ€ã€æ—¶é—´æ§½çŠ¶æ€ä¿æŒä¸€è‡´
- **æ—¶åºæ€§**: ä¸èƒ½é¢„è®¢è¿‡å»æ—¶é—´çš„æ—¶é—´æ§½

### ğŸ”„ è®¢å•å·ç”Ÿæˆè§„åˆ™
```typescript
function generateOrderNumber(): string {
  const date = new Date();
  const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
  
  // è·å–å½“å¤©è®¢å•æ•°é‡ä½œä¸ºåºå·
  const dailyCount = await this.getDailyOrderCount(date);
  const sequence = (dailyCount + 1).toString().padStart(3, '0');
  
  return `ORD${dateStr}${sequence}`;
}
```

---

## çŠ¶æ€ç®¡ç†

### ğŸ“Š è®¢å•çŠ¶æ€æšä¸¾
```typescript
enum OrderStatus {
  PENDING = 'PENDING',           // å¾…ç¡®è®¤
  CONFIRMED = 'CONFIRMED',       // å·²ç¡®è®¤
  IN_PROGRESS = 'IN_PROGRESS',   // æœåŠ¡è¿›è¡Œä¸­
  COMPLETED = 'COMPLETED',       // å·²å®Œæˆ
  CANCELLED = 'CANCELLED',       // å·²å–æ¶ˆ
  REFUNDED = 'REFUNDED'          // å·²é€€æ¬¾
}

enum PaymentStatus {
  PENDING = 'PENDING',           // å¾…æ”¯ä»˜
  PARTIAL_PAID = 'PARTIAL_PAID', // éƒ¨åˆ†æ”¯ä»˜
  PAID = 'PAID',                 // å·²æ”¯ä»˜
  REFUNDING = 'REFUNDING',       // é€€æ¬¾ä¸­
  REFUNDED = 'REFUNDED'          // å·²é€€æ¬¾
}
```

### ğŸ”„ çŠ¶æ€æµè½¬å›¾
```
è®¢å•çŠ¶æ€æµè½¬:
PENDING â†’ CONFIRMED â†’ IN_PROGRESS â†’ COMPLETED
   â†“         â†“            â†“
CANCELLED â† CANCELLED â† CANCELLED
   â†“
REFUNDED

æ”¯ä»˜çŠ¶æ€æµè½¬:
PENDING â†’ PARTIAL_PAID â†’ PAID
   â†“           â†“          â†“
REFUNDING â† REFUNDING â† REFUNDING
   â†“
REFUNDED
```

### ğŸ›¡ï¸ çŠ¶æ€è½¬æ¢éªŒè¯
```typescript
const VALID_STATUS_TRANSITIONS = {
  PENDING: ['CONFIRMED', 'CANCELLED'],
  CONFIRMED: ['IN_PROGRESS', 'CANCELLED'],
  IN_PROGRESS: ['COMPLETED', 'CANCELLED'],
  COMPLETED: [],
  CANCELLED: ['REFUNDED'],
  REFUNDED: []
};

function validateStatusTransition(currentStatus: OrderStatus, newStatus: OrderStatus): boolean {
  return VALID_STATUS_TRANSITIONS[currentStatus]?.includes(newStatus) || false;
}
```

---

## æŠ€æœ¯å®ç°

### ğŸ”§ æ ¸å¿ƒæŠ€æœ¯æ ˆ
- **NestJS**: Webæ¡†æ¶å’Œä¾èµ–æ³¨å…¥
- **Prisma**: ORMæ•°æ®åº“è®¿é—®å’Œäº‹åŠ¡å¤„ç†
- **TypeScript**: ç±»å‹å®‰å…¨
- **class-validator**: æ•°æ®éªŒè¯
- **Swagger**: APIæ–‡æ¡£ç”Ÿæˆ

### ğŸ“‹ æœåŠ¡æ ¸å¿ƒå®ç°
```typescript
@Injectable()
export class OrdersService {
  constructor(private readonly prisma: PrismaService) {}

  async create(createOrderDto: CreateOrderDto): Promise<Order> {
    return await this.prisma.$transaction(async (tx) => {
      // 1. éªŒè¯ç”¨æˆ·å­˜åœ¨
      const user = await tx.user.findUnique({ where: { id: createOrderDto.userId } });
      if (!user) throw new NotFoundException('ç”¨æˆ·ä¸å­˜åœ¨');

      // 2. éªŒè¯å¥—é¤å­˜åœ¨ä¸”æ¿€æ´»
      const package = await tx.package.findUnique({ where: { id: createOrderDto.packageId } });
      if (!package || !package.isActive) throw new NotFoundException('å¥—é¤ä¸å­˜åœ¨æˆ–å·²ä¸‹æ¶');

      // 3. éªŒè¯æ—¶é—´æ§½å¯ç”¨å¹¶é¢„è®¢
      const timeSlot = await tx.timeSlot.findUnique({ where: { id: createOrderDto.timeSlotId } });
      if (!timeSlot) throw new NotFoundException('æ—¶é—´æ§½ä¸å­˜åœ¨');
      if (timeSlot.isBooked) throw new ConflictException('æ—¶é—´æ§½å·²è¢«é¢„è®¢');

      // 4. é¢„è®¢æ—¶é—´æ§½
      await tx.timeSlot.update({
        where: { id: createOrderDto.timeSlotId },
        data: { isBooked: true }
      });

      // 5. ç”Ÿæˆè®¢å•å·
      const orderNo = await this.generateOrderNumber();

      // 6. åˆ›å»ºè®¢å•
      return await tx.order.create({
        data: {
          orderNo,
          ...createOrderDto,
          status: OrderStatus.PENDING,
          paymentStatus: PaymentStatus.PENDING,
          totalAmount: package.price,
        },
        include: {
          user: { select: { id: true, nickname: true, phone: true } },
          package: { select: { id: true, name: true, price: true, duration: true } },
          timeSlot: true,
        },
      });
    });
  }

  async update(id: number, updateOrderDto: UpdateOrderDto): Promise<Order> {
    return await this.prisma.$transaction(async (tx) => {
      // 1. è·å–ç°æœ‰è®¢å•
      const existingOrder = await tx.order.findUnique({
        where: { id },
        include: { timeSlot: true }
      });

      if (!existingOrder) {
        throw new NotFoundException('è®¢å•ä¸å­˜åœ¨');
      }

      // 2. éªŒè¯çŠ¶æ€è½¬æ¢
      if (updateOrderDto.status) {
        if (!this.validateStatusTransition(existingOrder.status, updateOrderDto.status)) {
          throw new BadRequestException('æ— æ•ˆçš„çŠ¶æ€è½¬æ¢');
        }
      }

      // 3. å¤„ç†æ—¶é—´æ§½å˜æ›´
      if (updateOrderDto.timeSlotId && updateOrderDto.timeSlotId !== existingOrder.timeSlotId) {
        await this.handleTimeSlotChange(tx, existingOrder.timeSlotId, updateOrderDto.timeSlotId);
      }

      // 4. æ›´æ–°è®¢å•
      return await tx.order.update({
        where: { id },
        data: updateOrderDto,
        include: {
          user: { select: { id: true, nickname: true, phone: true } },
          package: { select: { id: true, name: true, price: true, duration: true } },
          timeSlot: true,
          payments: true,
        },
      });
    });
  }

  private async handleTimeSlotChange(
    tx: any, 
    oldTimeSlotId: number, 
    newTimeSlotId: number
  ): Promise<void> {
    // æ£€æŸ¥æ–°æ—¶é—´æ§½æ˜¯å¦å¯ç”¨
    const newTimeSlot = await tx.timeSlot.findUnique({ where: { id: newTimeSlotId } });
    if (!newTimeSlot || newTimeSlot.isBooked) {
      throw new ConflictException('æ–°æ—¶é—´æ§½ä¸å¯ç”¨');
    }

    // é‡Šæ”¾æ—§æ—¶é—´æ§½
    await tx.timeSlot.update({
      where: { id: oldTimeSlotId },
      data: { isBooked: false }
    });

    // é¢„è®¢æ–°æ—¶é—´æ§½
    await tx.timeSlot.update({
      where: { id: newTimeSlotId },
      data: { isBooked: true }
    });
  }
}
```

### ğŸ—„ï¸ å¤æ‚æŸ¥è¯¢å®ç°
```typescript
// è·å–è®¢å•è¯¦æƒ…ï¼ˆåŒ…å«å®Œæ•´å…³è”æ•°æ®ï¼‰
async findOne(id: number): Promise<Order> {
  const order = await this.prisma.order.findUnique({
    where: { id },
    include: {
      user: {
        select: {
          id: true,
          nickname: true,
          phone: true,
          avatar: true,
        },
      },
      package: {
        select: {
          id: true,
          name: true,
          description: true,
          price: true,
          duration: true,
          features: true,
        },
      },
      timeSlot: {
        select: {
          id: true,
          date: true,
          startTime: true,
          endTime: true,
          isBooked: true,
        },
      },
      payments: {
        select: {
          id: true,
          amount: true,
          paymentType: true,
          status: true,
          transactionId: true,
          paidAt: true,
          createdAt: true,
        },
        orderBy: {
          createdAt: 'desc',
        },
      },
    },
  });

  if (!order) {
    throw new NotFoundException('è®¢å•ä¸å­˜åœ¨');
  }

  return order;
}

// ç”¨æˆ·è®¢å•æŸ¥è¯¢ï¼ˆå¸¦åˆ†é¡µï¼‰
async findByUserPaginated(
  userId: number, 
  page: number = 1, 
  limit: number = 10
): Promise<PaginatedResult<Order>> {
  const skip = (page - 1) * limit;

  const [orders, total] = await Promise.all([
    this.prisma.order.findMany({
      where: { userId },
      skip,
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        package: { select: { id: true, name: true, price: true } },
        timeSlot: { select: { id: true, date: true, startTime: true, endTime: true } },
      },
    }),
    this.prisma.order.count({ where: { userId } }),
  ]);

  return {
    data: orders,
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit),
  };
}
```

---

## ä½¿ç”¨ç¤ºä¾‹

### ğŸ¯ å‰ç«¯é›†æˆç¤ºä¾‹

#### å¾®ä¿¡å°ç¨‹åºè®¢å•åˆ›å»º
```javascript
// åˆ›å»ºè®¢å•é¡µé¢
Page({
  data: {
    selectedPackage: null,
    selectedTimeSlot: null,
    contactPhone: '',
    notes: '',
    submitting: false
  },

  onLoad(options) {
    // ä»ä¸Šä¸€é¡µè·å–é€‰æ‹©çš„å¥—é¤å’Œæ—¶é—´æ§½
    const selectedPackage = wx.getStorageSync('selectedPackage');
    const selectedTimeSlot = wx.getStorageSync('selectedTimeSlot');
    
    this.setData({
      selectedPackage,
      selectedTimeSlot
    });
  },

  async submitOrder() {
    if (this.data.submitting) return;

    const { selectedPackage, selectedTimeSlot, contactPhone, notes } = this.data;
    
    if (!contactPhone) {
      wx.showToast({ title: 'è¯·å¡«å†™è”ç³»ç”µè¯', icon: 'error' });
      return;
    }

    this.setData({ submitting: true });

    try {
      const userInfo = wx.getStorageSync('userInfo');
      
      const res = await wx.request({
        url: 'https://api.example.com/orders',
        method: 'POST',
        data: {
          userId: userInfo.id,
          packageId: selectedPackage.id,
          timeSlotId: selectedTimeSlot.id,
          contactPhone: contactPhone,
          notes: notes
        }
      });

      if (res.statusCode === 201) {
        wx.showToast({ title: 'è®¢å•åˆ›å»ºæˆåŠŸ', icon: 'success' });
        
        // è·³è½¬åˆ°è®¢å•è¯¦æƒ…é¡µ
        wx.redirectTo({
          url: `/pages/order-detail/order-detail?orderId=${res.data.id}`
        });
      }
    } catch (error) {
      wx.showToast({ title: 'åˆ›å»ºè®¢å•å¤±è´¥', icon: 'error' });
    } finally {
      this.setData({ submitting: false });
    }
  },

  onPhoneInput(e) {
    this.setData({ contactPhone: e.detail.value });
  },

  onNotesInput(e) {
    this.setData({ notes: e.detail.value });
  }
});
```

```html
<!-- è®¢å•åˆ›å»ºé¡µé¢æ¨¡æ¿ -->
<view class="order-create-container">
  <view class="section">
    <view class="section-title">é€‰æ‹©çš„å¥—é¤</view>
    <view class="package-info">
      <view class="package-name">{{selectedPackage.name}}</view>
      <view class="package-price">Â¥{{selectedPackage.price}}</view>
      <view class="package-duration">æ—¶é•¿ï¼š{{selectedPackage.duration}}åˆ†é’Ÿ</view>
    </view>
  </view>

  <view class="section">
    <view class="section-title">é¢„çº¦æ—¶é—´</view>
    <view class="time-info">
      <view class="date">{{selectedTimeSlot.date}}</view>
      <view class="time">{{selectedTimeSlot.startTime}} - {{selectedTimeSlot.endTime}}</view>
    </view>
  </view>

  <view class="section">
    <view class="section-title">è”ç³»ä¿¡æ¯</view>
    <input 
      class="input"
      type="number"
      placeholder="è¯·è¾“å…¥è”ç³»ç”µè¯"
      value="{{contactPhone}}"
      bindinput="onPhoneInput"
    />
  </view>

  <view class="section">
    <view class="section-title">å¤‡æ³¨ä¿¡æ¯</view>
    <textarea 
      class="textarea"
      placeholder="è¯·è¾“å…¥ç‰¹æ®Šè¦æ±‚æˆ–å¤‡æ³¨"
      value="{{notes}}"
      bindinput="onNotesInput"
    ></textarea>
  </view>

  <view class="total-amount">
    æ€»é‡‘é¢ï¼šÂ¥{{selectedPackage.price}}
  </view>

  <button 
    class="submit-btn" 
    bindtap="submitOrder"
    disabled="{{submitting}}"
  >
    {{submitting ? 'æäº¤ä¸­...' : 'ç¡®è®¤è®¢å•'}}
  </button>
</view>
```

#### React è®¢å•ç®¡ç†ç»„ä»¶
```typescript
// è®¢å•æœåŠ¡ç±»
class OrderService {
  private baseURL = '/api/orders';

  async createOrder(orderData: CreateOrderDto): Promise<Order> {
    const response = await fetch(this.baseURL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(orderData),
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'åˆ›å»ºè®¢å•å¤±è´¥');
    }
    
    return response.json();
  }

  async getUserOrders(userId: number, page = 1, limit = 10): Promise<PaginatedResult<Order>> {
    const response = await fetch(`${this.baseURL}/user/${userId}?page=${page}&limit=${limit}`);
    if (!response.ok) throw new Error('è·å–è®¢å•åˆ—è¡¨å¤±è´¥');
    return response.json();
  }

  async getOrderDetail(orderId: number): Promise<Order> {
    const response = await fetch(`${this.baseURL}/${orderId}`);
    if (!response.ok) throw new Error('è·å–è®¢å•è¯¦æƒ…å¤±è´¥');
    return response.json();
  }

  async updateOrderStatus(orderId: number, status: OrderStatus): Promise<Order> {
    const response = await fetch(`${this.baseURL}/${orderId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ status }),
    });
    if (!response.ok) throw new Error('æ›´æ–°è®¢å•çŠ¶æ€å¤±è´¥');
    return response.json();
  }
}

// React Hook
function useOrders(userId?: number) {
  const [orders, setOrders] = useState<Order[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
  });

  const orderService = new OrderService();

  const fetchOrders = useCallback(async (page = 1) => {
    if (!userId) return;
    
    setLoading(true);
    setError(null);

    try {
      const result = await orderService.getUserOrders(userId, page, pagination.limit);
      setOrders(page === 1 ? result.data : [...orders, ...result.data]);
      setPagination({
        page: result.page,
        limit: result.limit,
        total: result.total,
        totalPages: result.totalPages,
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'è·å–è®¢å•å¤±è´¥');
    } finally {
      setLoading(false);
    }
  }, [userId, pagination.limit]);

  useEffect(() => {
    if (userId) {
      fetchOrders(1);
    }
  }, [userId]);

  const createOrder = async (orderData: CreateOrderDto) => {
    try {
      const newOrder = await orderService.createOrder(orderData);
      setOrders(prev => [newOrder, ...prev]);
      return newOrder;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'åˆ›å»ºè®¢å•å¤±è´¥');
      throw err;
    }
  };

  const updateOrderStatus = async (orderId: number, status: OrderStatus) => {
    try {
      const updatedOrder = await orderService.updateOrderStatus(orderId, status);
      setOrders(prev => prev.map(order => 
        order.id === orderId ? updatedOrder : order
      ));
      return updatedOrder;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'æ›´æ–°çŠ¶æ€å¤±è´¥');
      throw err;
    }
  };

  return {
    orders,
    loading,
    error,
    pagination,
    createOrder,
    updateOrderStatus,
    fetchMore: () => fetchOrders(pagination.page + 1),
    refresh: () => fetchOrders(1),
  };
}

// è®¢å•åˆ—è¡¨ç»„ä»¶
function OrderList({ userId }: { userId: number }) {
  const { orders, loading, error, pagination, updateOrderStatus, fetchMore } = useOrders(userId);

  const getStatusColor = (status: OrderStatus) => {
    const colors = {
      PENDING: '#orange',
      CONFIRMED: '#blue',
      IN_PROGRESS: '#purple',
      COMPLETED: '#green',
      CANCELLED: '#red',
      REFUNDED: '#gray',
    };
    return colors[status] || '#gray';
  };

  const getStatusText = (status: OrderStatus) => {
    const texts = {
      PENDING: 'å¾…ç¡®è®¤',
      CONFIRMED: 'å·²ç¡®è®¤',
      IN_PROGRESS: 'è¿›è¡Œä¸­',
      COMPLETED: 'å·²å®Œæˆ',
      CANCELLED: 'å·²å–æ¶ˆ',
      REFUNDED: 'å·²é€€æ¬¾',
    };
    return texts[status] || status;
  };

  if (loading && orders.length === 0) {
    return <div className="loading">åŠ è½½ä¸­...</div>;
  }

  if (error && orders.length === 0) {
    return <div className="error">é”™è¯¯: {error}</div>;
  }

  return (
    <div className="order-list">
      <h2>æˆ‘çš„è®¢å•</h2>
      
      {orders.length === 0 ? (
        <div className="empty">æš‚æ— è®¢å•</div>
      ) : (
        <>
          {orders.map(order => (
            <div key={order.id} className="order-item">
              <div className="order-header">
                <span className="order-no">è®¢å•å·: {order.orderNo}</span>
                <span 
                  className="status"
                  style={{ color: getStatusColor(order.status) }}
                >
                  {getStatusText(order.status)}
                </span>
              </div>
              
              <div className="order-content">
                <div className="package-info">
                  <h4>{order.package.name}</h4>
                  <p>æ—¶é•¿: {order.package.duration}åˆ†é’Ÿ</p>
                </div>
                
                <div className="time-info">
                  <p>é¢„çº¦æ—¶é—´: {format(new Date(order.timeSlot.date), 'yyyy-MM-dd')}</p>
                  <p>
                    {format(new Date(order.timeSlot.startTime), 'HH:mm')} - 
                    {format(new Date(order.timeSlot.endTime), 'HH:mm')}
                  </p>
                </div>
                
                <div className="amount">
                  æ€»é‡‘é¢: Â¥{order.totalAmount}
                </div>
              </div>
              
              <div className="order-actions">
                {order.status === 'PENDING' && (
                  <button onClick={() => updateOrderStatus(order.id, 'CANCELLED')}>
                    å–æ¶ˆè®¢å•
                  </button>
                )}
                <button onClick={() => viewOrderDetail(order.id)}>
                  æŸ¥çœ‹è¯¦æƒ…
                </button>
              </div>
            </div>
          ))}
          
          {pagination.page < pagination.totalPages && (
            <button 
              className="load-more"
              onClick={fetchMore}
              disabled={loading}
            >
              {loading ? 'åŠ è½½ä¸­...' : 'åŠ è½½æ›´å¤š'}
            </button>
          )}
        </>
      )}
    </div>
  );
}
```

---

## è®¢å•å¤„ç†æµç¨‹

### ğŸ“‹ å®Œæ•´ä¸šåŠ¡æµç¨‹
```mermaid
graph TD
    A[å®¢æˆ·é€‰æ‹©å¥—é¤] --> B[é€‰æ‹©æ—¶é—´æ§½]
    B --> C[å¡«å†™è®¢å•ä¿¡æ¯]
    C --> D[åˆ›å»ºè®¢å•]
    D --> E[è®¢å•å¾…ç¡®è®¤]
    E --> F{å•†å®¶ç¡®è®¤}
    F -->|åŒæ„| G[è®¢å•å·²ç¡®è®¤]
    F -->|æ‹’ç»| H[è®¢å•å–æ¶ˆ]
    G --> I[å®¢æˆ·æ”¯ä»˜]
    I --> J[æ”¯ä»˜å®Œæˆ]
    J --> K[æœåŠ¡è¿›è¡Œä¸­]
    K --> L[æœåŠ¡å®Œæˆ]
    L --> M[è®¢å•å®Œæˆ]
    
    H --> N[é‡Šæ”¾æ—¶é—´æ§½]
    E --> O{å®¢æˆ·å–æ¶ˆ}
    O -->|æ˜¯| H
    G --> P{å®¢æˆ·å–æ¶ˆ}
    P -->|æ˜¯| Q[å¤„ç†é€€æ¬¾]
    Q --> R[è®¢å•å·²é€€æ¬¾]
```

### ğŸ”„ çŠ¶æ€åŒæ­¥æœºåˆ¶
```typescript
// è®¢å•çŠ¶æ€åŒæ­¥æœåŠ¡
@Injectable()
export class OrderStatusSyncService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly paymentService: PaymentService,
    private readonly timeSlotsService: TimeSlotsService,
  ) {}

  async syncOrderStatus(orderId: number): Promise<void> {
    const order = await this.prisma.order.findUnique({
      where: { id: orderId },
      include: { payments: true }
    });

    if (!order) return;

    // æ ¹æ®æ”¯ä»˜çŠ¶æ€åŒæ­¥è®¢å•çŠ¶æ€
    const totalPaid = order.payments
      .filter(p => p.status === 'PAID')
      .reduce((sum, p) => sum + p.amount, 0);

    if (totalPaid >= order.totalAmount && order.status === 'PENDING') {
      await this.updateOrderStatus(orderId, 'CONFIRMED');
    }
  }

  async handleOrderCancellation(orderId: number): Promise<void> {
    await this.prisma.$transaction(async (tx) => {
      // æ›´æ–°è®¢å•çŠ¶æ€
      const order = await tx.order.update({
        where: { id: orderId },
        data: { status: 'CANCELLED' },
        include: { timeSlot: true }
      });

      // é‡Šæ”¾æ—¶é—´æ§½
      if (order.timeSlot) {
        await tx.timeSlot.update({
          where: { id: order.timeSlotId },
          data: { isBooked: false }
        });
      }

      // å¤„ç†é€€æ¬¾é€»è¾‘
      await this.processRefund(orderId);
    });
  }

  private async processRefund(orderId: number): Promise<void> {
    // é€€æ¬¾é€»è¾‘å®ç°
    // 1. è®¡ç®—é€€æ¬¾é‡‘é¢
    // 2. è°ƒç”¨æ”¯ä»˜æœåŠ¡å¤„ç†é€€æ¬¾
    // 3. æ›´æ–°æ”¯ä»˜çŠ¶æ€
    // 4. æ›´æ–°è®¢å•çŠ¶æ€ä¸ºå·²é€€æ¬¾
  }
}
```

---

## å¸¸è§é—®é¢˜

### â“ FAQ

#### Q1: å¦‚ä½•å¤„ç†è®¢å•åˆ›å»ºæ—¶çš„å¹¶å‘å†²çªï¼Ÿ
**A**: ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡å’Œä¹è§‚é”æœºåˆ¶ï¼Œç¡®ä¿æ—¶é—´æ§½é¢„è®¢çš„åŸå­æ€§ã€‚

```typescript
async createOrderSafely(createOrderDto: CreateOrderDto): Promise<Order> {
  const maxRetries = 3;
  let attempt = 0;

  while (attempt < maxRetries) {
    try {
      return await this.prisma.$transaction(async (tx) => {
        // ä½¿ç”¨SELECT FOR UPDATEé”å®šæ—¶é—´æ§½
        const timeSlot = await tx.timeSlot.findUnique({
          where: { id: createOrderDto.timeSlotId },
          // åœ¨å®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨FOR UPDATEé”
        });

        if (!timeSlot || timeSlot.isBooked) {
          throw new ConflictException('æ—¶é—´æ§½ä¸å¯ç”¨');
        }

        // åŸå­æ€§åˆ›å»ºè®¢å•å’Œæ›´æ–°æ—¶é—´æ§½
        const order = await tx.order.create({ /* ... */ });
        await tx.timeSlot.update({
          where: { id: createOrderDto.timeSlotId },
          data: { isBooked: true }
        });

        return order;
      });
    } catch (error) {
      attempt++;
      if (attempt >= maxRetries) throw error;
      
      // çŸ­æš‚å»¶è¿Ÿåé‡è¯•
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
}
```

#### Q2: å¦‚ä½•å®ç°è®¢å•çš„è½¯åˆ é™¤ï¼Ÿ
**A**: æ·»åŠ deletedAtå­—æ®µï¼Œæ ‡è®°åˆ é™¤çŠ¶æ€è€Œä¸æ˜¯ç‰©ç†åˆ é™¤ã€‚

```typescript
// æ‰©å±•è®¢å•æ¨¡å‹
model Order {
  // ... ç°æœ‰å­—æ®µ
  deletedAt DateTime? // è½¯åˆ é™¤å­—æ®µ
}

// è½¯åˆ é™¤å®ç°
async softDelete(id: number): Promise<void> {
  await this.prisma.order.update({
    where: { id },
    data: { 
      deletedAt: new Date(),
      status: 'CANCELLED'
    }
  });
}

// æŸ¥è¯¢æ—¶æ’é™¤å·²åˆ é™¤è®¢å•
async findAll(): Promise<Order[]> {
  return await this.prisma.order.findMany({
    where: { deletedAt: null }
  });
}
```

#### Q3: å¦‚ä½•å¤„ç†è®¢å•çš„éƒ¨åˆ†é€€æ¬¾ï¼Ÿ
**A**: æ‰©å±•æ”¯ä»˜æ¨¡å—ï¼Œæ”¯æŒéƒ¨åˆ†é€€æ¬¾è®°å½•ã€‚

```typescript
// éƒ¨åˆ†é€€æ¬¾å¤„ç†
async processPartialRefund(orderId: number, refundAmount: number): Promise<Payment> {
  return await this.prisma.$transaction(async (tx) => {
    // åˆ›å»ºé€€æ¬¾è®°å½•
    const refundPayment = await tx.payment.create({
      data: {
        orderId,
        amount: -refundAmount, // è´Ÿæ•°è¡¨ç¤ºé€€æ¬¾
        paymentType: 'REFUND',
        status: 'PAID',
        paidAt: new Date(),
      }
    });

    // æ›´æ–°è®¢å•æ”¯ä»˜çŠ¶æ€
    const order = await tx.order.findUnique({
      where: { id: orderId },
      include: { payments: true }
    });

    const totalPaid = order.payments
      .filter(p => p.status === 'PAID')
      .reduce((sum, p) => sum + p.amount, 0);

    const newPaymentStatus = totalPaid <= 0 ? 'REFUNDED' : 
                            totalPaid < order.totalAmount ? 'PARTIAL_PAID' : 'PAID';

    await tx.order.update({
      where: { id: orderId },
      data: { paymentStatus: newPaymentStatus }
    });

    return refundPayment;
  });
}
```

#### Q4: å¦‚ä½•å®ç°è®¢å•çš„è‡ªåŠ¨çŠ¶æ€æµè½¬ï¼Ÿ
**A**: ä½¿ç”¨å®šæ—¶ä»»åŠ¡å’Œäº‹ä»¶é©±åŠ¨æœºåˆ¶ã€‚

```typescript
// è®¢å•è‡ªåŠ¨çŠ¶æ€æµè½¬æœåŠ¡
@Injectable()
export class OrderAutoStatusService {
  @Cron('0 */10 * * * *') // æ¯10åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
  async autoUpdateOrderStatus(): Promise<void> {
    // è‡ªåŠ¨ç¡®è®¤å·²æ”¯ä»˜çš„è®¢å•
    await this.prisma.order.updateMany({
      where: {
        status: 'PENDING',
        paymentStatus: 'PAID',
        createdAt: {
          lte: new Date(Date.now() - 30 * 60 * 1000) // 30åˆ†é’Ÿå‰
        }
      },
      data: { status: 'CONFIRMED' }
    });

    // è‡ªåŠ¨å–æ¶ˆè¶…æ—¶æœªæ”¯ä»˜çš„è®¢å•
    await this.cancelOverdueOrders();
  }

  private async cancelOverdueOrders(): Promise<void> {
    const overdueOrders = await this.prisma.order.findMany({
      where: {
        status: 'PENDING',
        paymentStatus: 'PENDING',
        createdAt: {
          lte: new Date(Date.now() - 24 * 60 * 60 * 1000) // 24å°æ—¶å‰
        }
      }
    });

    for (const order of overdueOrders) {
      await this.orderStatusSyncService.handleOrderCancellation(order.id);
    }
  }
}
```

#### Q5: å¦‚ä½•å®ç°è®¢å•çš„æœç´¢å’Œè¿‡æ»¤ï¼Ÿ
**A**: æ‰©å±•æŸ¥è¯¢æ¥å£ï¼Œæ”¯æŒå¤šæ¡ä»¶æœç´¢ã€‚

```typescript
interface OrderSearchDto {
  keyword?: string;      // å…³é”®è¯æœç´¢ï¼ˆè®¢å•å·ã€ç”¨æˆ·æ˜µç§°ï¼‰
  status?: OrderStatus[]; // çŠ¶æ€è¿‡æ»¤
  paymentStatus?: PaymentStatus[]; // æ”¯ä»˜çŠ¶æ€è¿‡æ»¤
  startDate?: string;    // å¼€å§‹æ—¥æœŸ
  endDate?: string;      // ç»“æŸæ—¥æœŸ
  packageId?: number;    // å¥—é¤è¿‡æ»¤
  page?: number;         // é¡µç 
  limit?: number;        // æ¯é¡µæ•°é‡
}

async searchOrders(searchDto: OrderSearchDto): Promise<PaginatedResult<Order>> {
  const {
    keyword,
    status,
    paymentStatus,
    startDate,
    endDate,
    packageId,
    page = 1,
    limit = 10
  } = searchDto;

  const where: any = {};

  // å…³é”®è¯æœç´¢
  if (keyword) {
    where.OR = [
      { orderNo: { contains: keyword, mode: 'insensitive' } },
      { user: { nickname: { contains: keyword, mode: 'insensitive' } } },
      { contactPhone: { contains: keyword } }
    ];
  }

  // çŠ¶æ€è¿‡æ»¤
  if (status?.length) {
    where.status = { in: status };
  }

  if (paymentStatus?.length) {
    where.paymentStatus = { in: paymentStatus };
  }

  // æ—¥æœŸèŒƒå›´è¿‡æ»¤
  if (startDate || endDate) {
    where.createdAt = {};
    if (startDate) where.createdAt.gte = new Date(startDate);
    if (endDate) where.createdAt.lte = new Date(endDate);
  }

  // å¥—é¤è¿‡æ»¤
  if (packageId) {
    where.packageId = packageId;
  }

  const skip = (page - 1) * limit;

  const [orders, total] = await Promise.all([
    this.prisma.order.findMany({
      where,
      skip,
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        user: { select: { id: true, nickname: true, phone: true } },
        package: { select: { id: true, name: true, price: true } },
        timeSlot: { select: { date: true, startTime: true, endTime: true } }
      }
    }),
    this.prisma.order.count({ where })
  ]);

  return {
    data: orders,
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit)
  };
}
```

---

## æ€»ç»“

è®¢å•æ¨¡å—æ˜¯æ•´ä¸ªå©´å„¿æ‘„å½±å·¥ä½œå®¤ç³»ç»Ÿçš„æ ¸å¿ƒä¸šåŠ¡æ¨¡å—ï¼Œæä¾›äº†ï¼š

âœ… **å®Œæ•´çš„è®¢å•ç”Ÿå‘½å‘¨æœŸç®¡ç†**: ä»åˆ›å»ºåˆ°å®Œæˆçš„å…¨æµç¨‹ç®¡ç†  
âœ… **æ™ºèƒ½çš„ä¸šåŠ¡é€»è¾‘å¤„ç†**: è‡ªåŠ¨åŒ–çš„çŠ¶æ€æµè½¬å’Œæ•°æ®åŒæ­¥  
âœ… **å¼ºå¤§çš„å…³è”æ•°æ®ç®¡ç†**: ç»Ÿä¸€ç®¡ç†ç”¨æˆ·ã€å¥—é¤ã€æ—¶é—´æ§½ã€æ”¯ä»˜ç­‰å…³è”ä¿¡æ¯  
âœ… **ä¸¥æ ¼çš„æ•°æ®ä¸€è‡´æ€§ä¿è¯**: äº‹åŠ¡å¤„ç†ç¡®ä¿æ•°æ®å®Œæ•´æ€§  
âœ… **çµæ´»çš„æŸ¥è¯¢å’Œè¿‡æ»¤**: æ”¯æŒå¤šç»´åº¦çš„è®¢å•æŸ¥è¯¢å’Œç®¡ç†  
âœ… **å®Œå–„çš„å¼‚å¸¸å¤„ç†æœºåˆ¶**: å¤„ç†å„ç§è¾¹ç•Œæƒ…å†µå’Œå¼‚å¸¸åœºæ™¯  

è¯¥æ¨¡å—ä¸ºæ•´ä¸ªä¸šåŠ¡ç³»ç»Ÿæä¾›äº†ç¨³å®šå¯é çš„è®¢å•ç®¡ç†åŸºç¡€ï¼Œæ”¯æŒå¤æ‚çš„ä¸šåŠ¡åœºæ™¯å’Œé«˜å¹¶å‘è®¿é—®éœ€æ±‚ã€‚

---

*æ–‡æ¡£ç‰ˆæœ¬: 1.0.0*  
*æœ€åæ›´æ–°: 2024å¹´7æœˆ25æ—¥*  
*ç»´æŠ¤è€…: å¼€å‘å›¢é˜Ÿ*

# ğŸ’³ æ”¯ä»˜æ¨¡å—åŠŸèƒ½è¯´æ˜æ–‡æ¡£

## ç›®å½•
- [æ¨¡å—æ¦‚è¿°](#æ¨¡å—æ¦‚è¿°)
- [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
- [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
- [API æ¥å£è¯¦æƒ…](#api-æ¥å£è¯¦æƒ…)
- [æ•°æ®æ¨¡å‹](#æ•°æ®æ¨¡å‹)
- [æ”¯ä»˜æµç¨‹](#æ”¯ä»˜æµç¨‹)
- [çŠ¶æ€ç®¡ç†](#çŠ¶æ€ç®¡ç†)
- [æŠ€æœ¯å®ç°](#æŠ€æœ¯å®ç°)
- [ç¬¬ä¸‰æ–¹é›†æˆ](#ç¬¬ä¸‰æ–¹é›†æˆ)
- [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
- [å®‰å…¨æœºåˆ¶](#å®‰å…¨æœºåˆ¶)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

---

## æ¨¡å—æ¦‚è¿°

### ğŸ¯ åŠŸèƒ½å®šä½
æ”¯ä»˜æ¨¡å—æ˜¯å©´å„¿æ‘„å½±å·¥ä½œå®¤ç³»ç»Ÿçš„å…³é”®è´¢åŠ¡æ¨¡å—ï¼Œè´Ÿè´£å¤„ç†æ‰€æœ‰è®¢å•çš„æ”¯ä»˜ç›¸å…³ä¸šåŠ¡ã€‚è¯¥æ¨¡å—ç®¡ç†æ”¯ä»˜è®°å½•ã€æ”¯ä»˜çŠ¶æ€ã€é€€æ¬¾å¤„ç†ç­‰æ ¸å¿ƒåŠŸèƒ½ï¼Œä¸ºæ•´ä¸ªå•†ä¸šæµç¨‹æä¾›èµ„é‡‘æµç®¡ç†æ”¯æŒï¼Œç¡®ä¿äº¤æ˜“çš„å®‰å…¨æ€§å’Œå¯è¿½æº¯æ€§ã€‚

### ğŸš€ ä¸»è¦ç‰¹æ€§
- **å¤šç§æ”¯ä»˜æ–¹å¼**: æ”¯æŒå®šé‡‘ã€å…¨æ¬¾ã€å°¾æ¬¾ç­‰å¤šç§æ”¯ä»˜ç±»å‹
- **å®Œæ•´çš„æ”¯ä»˜æµç¨‹**: åˆ›å»ºã€æ”¯ä»˜ã€ç¡®è®¤ã€é€€æ¬¾å…¨æµç¨‹ç®¡ç†
- **çŠ¶æ€æœºç®¡ç†**: ä¸¥æ ¼çš„æ”¯ä»˜çŠ¶æ€æµè½¬æ§åˆ¶
- **ç¬¬ä¸‰æ–¹é›†æˆ**: æ”¯æŒå¾®ä¿¡æ”¯ä»˜ã€æ”¯ä»˜å®ç­‰ä¸»æµæ”¯ä»˜å¹³å°
- **å®‰å…¨ä¿éšœ**: å®Œå–„çš„æ”¯ä»˜å®‰å…¨æœºåˆ¶å’Œæ•°æ®åŠ å¯†
- **å¯¹è´¦åŠŸèƒ½**: æ”¯æŒæ”¯ä»˜è®°å½•æŸ¥è¯¢å’Œè´¢åŠ¡å¯¹è´¦

### ğŸ“Š ä¸šåŠ¡ä»·å€¼
- ç¡®ä¿èµ„é‡‘å®‰å…¨å’Œäº¤æ˜“å¯é æ€§
- æä¾›çµæ´»çš„æ”¯ä»˜æ–¹å¼é€‰æ‹©
- æ”¯æŒè´¢åŠ¡ç®¡ç†å’Œæ•°æ®åˆ†æ
- æå‡ç”¨æˆ·æ”¯ä»˜ä½“éªŒ
- ä¸ºä¸šåŠ¡å†³ç­–æä¾›è´¢åŠ¡æ•°æ®æ”¯æŒ

---

## ç³»ç»Ÿæ¶æ„

### ğŸ—ï¸ æ¨¡å—ç»“æ„
```
src/modules/payments/
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-payment.dto.ts       # åˆ›å»ºæ”¯ä»˜DTO
â”‚   â””â”€â”€ update-payment.dto.ts       # æ›´æ–°æ”¯ä»˜DTOï¼ˆæš‚æœªä½¿ç”¨ï¼‰
â”œâ”€â”€ payments.controller.ts          # æ”¯ä»˜æ§åˆ¶å™¨
â”œâ”€â”€ payments.service.ts             # æ”¯ä»˜æœåŠ¡
â”œâ”€â”€ payment-state-machine.service.ts # æ”¯ä»˜çŠ¶æ€æœºæœåŠ¡
â””â”€â”€ payments.module.ts              # æ”¯ä»˜æ¨¡å—
```

### ğŸ”„ æ¶æ„å±‚æ¬¡
1. **æ§åˆ¶å™¨å±‚**: å¤„ç†HTTPè¯·æ±‚ï¼Œå‚æ•°éªŒè¯ï¼Œå“åº”æ ¼å¼åŒ–
2. **æœåŠ¡å±‚**: æ ¸å¿ƒæ”¯ä»˜é€»è¾‘ï¼ŒçŠ¶æ€ç®¡ç†ï¼Œç¬¬ä¸‰æ–¹æ¥å£è°ƒç”¨
3. **çŠ¶æ€æœºå±‚**: æ”¯ä»˜çŠ¶æ€æµè½¬æ§åˆ¶å’ŒéªŒè¯
4. **æ•°æ®è®¿é—®å±‚**: é€šè¿‡Prismaè¿›è¡Œæ•°æ®åº“æ“ä½œå’Œäº‹åŠ¡å¤„ç†
5. **é›†æˆå±‚**: ç¬¬ä¸‰æ–¹æ”¯ä»˜å¹³å°æ¥å£é›†æˆ

### ğŸ”— ä¾èµ–å…³ç³»
- **PrismaModule**: æ•°æ®åº“è®¿é—®æœåŠ¡
- **OrdersModule**: è®¢å•ä¿¡æ¯å…³è”
- **UsersModule**: ç”¨æˆ·ä¿¡æ¯å…³è”ï¼ˆé—´æ¥ï¼‰
- **ç¬¬ä¸‰æ–¹æ”¯ä»˜SDK**: å¾®ä¿¡æ”¯ä»˜ã€æ”¯ä»˜å®ç­‰
- **åŠ å¯†æœåŠ¡**: æ•æ„Ÿæ•°æ®åŠ å¯†å’Œç­¾åéªŒè¯

---

## æ ¸å¿ƒåŠŸèƒ½

### 1. æ”¯ä»˜è®°å½•åˆ›å»º
**åŠŸèƒ½æè¿°**: ä¸ºè®¢å•åˆ›å»ºæ”¯ä»˜è®°å½•ï¼Œæ”¯æŒå¤šç§æ”¯ä»˜ç±»å‹
- è®¢å•å…³è”éªŒè¯
- æ”¯ä»˜ç±»å‹å’Œé‡‘é¢éªŒè¯
- æ”¯ä»˜è®°å½•åˆå§‹åŒ–
- ç¬¬ä¸‰æ–¹æ”¯ä»˜è®¢å•åˆ›å»º
- æ”¯ä»˜é“¾æ¥æˆ–äºŒç»´ç ç”Ÿæˆ

### 2. æ”¯ä»˜çŠ¶æ€ç®¡ç†
**çŠ¶æ€æŸ¥è¯¢**: å®æ—¶æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€
**çŠ¶æ€æ›´æ–°**: å¤„ç†æ”¯ä»˜å›è°ƒå’ŒçŠ¶æ€å˜æ›´
**çŠ¶æ€åŒæ­¥**: ä¸ç¬¬ä¸‰æ–¹æ”¯ä»˜å¹³å°çŠ¶æ€åŒæ­¥
**å¼‚å¸¸å¤„ç†**: å¤„ç†æ”¯ä»˜å¼‚å¸¸å’Œè¶…æ—¶æƒ…å†µ

### 3. æ”¯ä»˜éªŒè¯
**å›è°ƒéªŒè¯**: éªŒè¯ç¬¬ä¸‰æ–¹æ”¯ä»˜å¹³å°å›è°ƒ
**ç­¾åéªŒè¯**: ç¡®ä¿æ”¯ä»˜æ•°æ®çš„å®Œæ•´æ€§å’ŒçœŸå®æ€§
**é‡‘é¢éªŒè¯**: éªŒè¯æ”¯ä»˜é‡‘é¢ä¸è®¢å•é‡‘é¢çš„ä¸€è‡´æ€§
**é‡å¤éªŒè¯**: é˜²æ­¢é‡å¤æ”¯ä»˜å’Œæ¶æ„æ”»å‡»

### 4. é€€æ¬¾å¤„ç†
**é€€æ¬¾ç”³è¯·**: åˆ›å»ºé€€æ¬¾ç”³è¯·è®°å½•
**é€€æ¬¾å¤„ç†**: è°ƒç”¨ç¬¬ä¸‰æ–¹å¹³å°é€€æ¬¾æ¥å£
**é€€æ¬¾ç¡®è®¤**: å¤„ç†é€€æ¬¾ç»“æœå’ŒçŠ¶æ€æ›´æ–°
**éƒ¨åˆ†é€€æ¬¾**: æ”¯æŒè®¢å•çš„éƒ¨åˆ†é€€æ¬¾å¤„ç†

---

## API æ¥å£è¯¦æƒ…

### ğŸ“‹ æ¥å£åˆ—è¡¨

| æ–¹æ³• | è·¯å¾„ | åŠŸèƒ½ | çŠ¶æ€ç  |
|------|------|------|--------|
| POST | `/payments` | åˆ›å»ºæ”¯ä»˜è®°å½• | 201, 400, 404 |
| GET | `/payments` | è·å–æ‰€æœ‰æ”¯ä»˜è®°å½• | 200, 500 |
| GET | `/payments/order/:orderId` | æ ¹æ®è®¢å•IDè·å–æ”¯ä»˜è®°å½• | 200, 404 |
| GET | `/payments/:id` | è·å–æ”¯ä»˜è®°å½•è¯¦æƒ… | 200, 404 |
| PATCH | `/payments/:id` | æ›´æ–°æ”¯ä»˜è®°å½• | 200, 400, 404 |
| PATCH | `/payments/:id/status/:status` | æ›´æ–°æ”¯ä»˜çŠ¶æ€ | 200, 400, 404 |

### ğŸ” æ¥å£è¯¦ç»†è¯´æ˜

#### 1. åˆ›å»ºæ”¯ä»˜è®°å½•
```http
POST /payments
Content-Type: application/json

{
  "orderId": "1",
  "paymentType": "DEPOSIT",
  "amount": 200.00
}
```

**è¯·æ±‚å‚æ•°**:
- `orderId` (å¿…å¡«): è®¢å•ID
- `paymentType` (å¿…å¡«): æ”¯ä»˜ç±»å‹ - DEPOSIT(å®šé‡‘) | FULL_PAYMENT(å…¨æ¬¾) | REMAINING(å°¾æ¬¾)
- `amount` (å¿…å¡«): æ”¯ä»˜é‡‘é¢ï¼Œå¿…é¡»å¤§äº0

**å“åº”ç¤ºä¾‹**:
```json
{
  "id": 1,
  "orderId": 1,
  "paymentType": "DEPOSIT",
  "amount": 200.00,
  "status": "CREATED",
  "transactionId": null,
  "paidAt": null,
  "createdAt": "2024-07-25T10:30:00.000Z",
  "updatedAt": "2024-07-25T10:30:00.000Z",
  "order": {
    "id": 1,
    "orderNo": "ORD20240725001",
    "totalAmount": 899.00,
    "user": {
      "id": 1,
      "nickname": "å°å®è´å¦ˆå¦ˆ"
    },
    "package": {
      "id": 1,
      "name": "ç»å…¸äº²å­æ‘„å½±å¥—é¤"
    }
  },
  "paymentUrl": "https://pay.weixin.qq.com/xxx", // æ”¯ä»˜é“¾æ¥
  "qrCode": "data:image/png;base64,xxx" // æ”¯ä»˜äºŒç»´ç 
}
```

#### 2. è·å–æ‰€æœ‰æ”¯ä»˜è®°å½•
```http
GET /payments
```

**å“åº”ç¤ºä¾‹**:
```json
[
  {
    "id": 1,
    "orderId": 1,
    "paymentType": "DEPOSIT",
    "amount": 200.00,
    "status": "PAID",
    "transactionId": "wx_tx_123456789",
    "paidAt": "2024-07-25T10:35:00.000Z",
    "createdAt": "2024-07-25T10:30:00.000Z",
    "updatedAt": "2024-07-25T10:35:00.000Z",
    "order": {
      "id": 1,
      "orderNo": "ORD20240725001",
      "user": {
        "id": 1,
        "nickname": "å°å®è´å¦ˆå¦ˆ"
      }
    }
  }
]
```

#### 3. æ ¹æ®è®¢å•IDè·å–æ”¯ä»˜è®°å½•
```http
GET /payments/order/1
```

**å“åº”ç¤ºä¾‹**: è¿”å›è¯¥è®¢å•çš„æ‰€æœ‰æ”¯ä»˜è®°å½•æ•°ç»„

#### 4. æ›´æ–°æ”¯ä»˜çŠ¶æ€
```http
PATCH /payments/1/status/PAID
```

**æ”¯æŒçš„çŠ¶æ€**:
- `CREATED`: å·²åˆ›å»º
- `PAID`: å·²æ”¯ä»˜
- `FAILED`: æ”¯ä»˜å¤±è´¥
- `REFUNDED`: å·²é€€æ¬¾

**å“åº”ç¤ºä¾‹**: è¿”å›æ›´æ–°åçš„æ”¯ä»˜è®°å½•

#### 5. æ›´æ–°æ”¯ä»˜è®°å½•ï¼ˆé€šç”¨æ›´æ–°ï¼‰
```http
PATCH /payments/1
Content-Type: application/json

{
  "status": "PAID",
  "transactionId": "wx_tx_123456789",
  "paidAt": "2024-07-25T10:35:00.000Z"
}
```

---

## æ•°æ®æ¨¡å‹

### ğŸ“Š æ”¯ä»˜æ•°æ®ç»“æ„
```typescript
interface Payment {
  id: number;              // ä¸»é”®ID
  orderId: number;         // è®¢å•ID
  paymentType: PaymentType; // æ”¯ä»˜ç±»å‹
  amount: number;          // æ”¯ä»˜é‡‘é¢
  status: PaymentStatus;   // æ”¯ä»˜çŠ¶æ€
  transactionId?: string;  // ç¬¬ä¸‰æ–¹äº¤æ˜“ID
  platformType?: string;   // æ”¯ä»˜å¹³å°ç±»å‹ï¼ˆå¾®ä¿¡ã€æ”¯ä»˜å®ç­‰ï¼‰
  paidAt?: Date;          // æ”¯ä»˜å®Œæˆæ—¶é—´
  refundedAt?: Date;      // é€€æ¬¾æ—¶é—´
  createdAt: Date;        // åˆ›å»ºæ—¶é—´
  updatedAt: Date;        // æ›´æ–°æ—¶é—´
  
  // å…³è”å…³ç³»
  order: Order;           // å…³è”è®¢å•
}
```

### ğŸ·ï¸ æšä¸¾å®šä¹‰
```typescript
enum PaymentType {
  DEPOSIT = 'DEPOSIT',           // å®šé‡‘
  FULL_PAYMENT = 'FULL_PAYMENT', // å…¨æ¬¾
  REMAINING = 'REMAINING'        // å°¾æ¬¾
}

enum PaymentStatus {
  CREATED = 'CREATED',     // å·²åˆ›å»ºï¼Œç­‰å¾…æ”¯ä»˜
  PAID = 'PAID',          // å·²æ”¯ä»˜
  FAILED = 'FAILED',      // æ”¯ä»˜å¤±è´¥
  REFUNDED = 'REFUNDED'   // å·²é€€æ¬¾
}

enum PlatformType {
  WECHAT = 'WECHAT',      // å¾®ä¿¡æ”¯ä»˜
  ALIPAY = 'ALIPAY',      // æ”¯ä»˜å®
  UNION = 'UNION',        // é“¶è”
  CASH = 'CASH'           // ç°é‡‘ï¼ˆçº¿ä¸‹ï¼‰
}
```

### ğŸ”— å…³è”å…³ç³»
- **å¤šå¯¹ä¸€**: Payment â†’ Order (å¤šä¸ªæ”¯ä»˜è®°å½•å±äºä¸€ä¸ªè®¢å•)
- **å¤šå¯¹ä¸€**: Payment â†’ User (é€šè¿‡è®¢å•å…³è”ç”¨æˆ·)

### ğŸ“ DTO ç»“æ„

#### CreatePaymentDto
```typescript
{
  orderId: string;        // å¿…å¡«ï¼Œè®¢å•ID
  paymentType: PaymentType; // å¿…å¡«ï¼Œæ”¯ä»˜ç±»å‹
  amount: number;         // å¿…å¡«ï¼Œæ”¯ä»˜é‡‘é¢
}
```

#### UpdatePaymentDto
```typescript
{
  status?: PaymentStatus;    // å¯é€‰ï¼Œæ”¯ä»˜çŠ¶æ€
  transactionId?: string;    // å¯é€‰ï¼Œç¬¬ä¸‰æ–¹äº¤æ˜“ID
  paidAt?: string;          // å¯é€‰ï¼Œæ”¯ä»˜å®Œæˆæ—¶é—´
  refundedAt?: string;      // å¯é€‰ï¼Œé€€æ¬¾æ—¶é—´
}
```

---

## æ”¯ä»˜æµç¨‹

### ğŸ’³ å®Œæ•´æ”¯ä»˜æµç¨‹å›¾
```mermaid
graph TD
    A[ç”¨æˆ·å‘èµ·æ”¯ä»˜] --> B[åˆ›å»ºæ”¯ä»˜è®°å½•]
    B --> C[è°ƒç”¨ç¬¬ä¸‰æ–¹æ”¯ä»˜æ¥å£]
    C --> D[ç”Ÿæˆæ”¯ä»˜é“¾æ¥/äºŒç»´ç ]
    D --> E[ç”¨æˆ·å®Œæˆæ”¯ä»˜]
    E --> F[æ¥æ”¶æ”¯ä»˜å›è°ƒ]
    F --> G[éªŒè¯å›è°ƒç­¾å]
    G --> H{éªŒè¯é€šè¿‡?}
    H -->|æ˜¯| I[æ›´æ–°æ”¯ä»˜çŠ¶æ€ä¸ºå·²æ”¯ä»˜]
    H -->|å¦| J[è®°å½•å¼‚å¸¸æ—¥å¿—]
    I --> K[æ›´æ–°è®¢å•æ”¯ä»˜çŠ¶æ€]
    K --> L[è§¦å‘åç»­ä¸šåŠ¡é€»è¾‘]
    
    M[æ”¯ä»˜è¶…æ—¶] --> N[æ›´æ–°çŠ¶æ€ä¸ºå¤±è´¥]
    O[ç”¨æˆ·ç”³è¯·é€€æ¬¾] --> P[åˆ›å»ºé€€æ¬¾è®°å½•]
    P --> Q[è°ƒç”¨ç¬¬ä¸‰æ–¹é€€æ¬¾æ¥å£]
    Q --> R[å¤„ç†é€€æ¬¾ç»“æœ]
```

### ğŸ”„ æ”¯ä»˜ç±»å‹åœºæ™¯

#### 1. å®šé‡‘æ”¯ä»˜æµç¨‹
```typescript
// å®šé‡‘æ”¯ä»˜ä¸šåŠ¡é€»è¾‘
async processDepositPayment(orderId: number): Promise<Payment> {
  const order = await this.getOrder(orderId);
  const depositAmount = this.calculateDepositAmount(order.totalAmount);
  
  return await this.createPayment({
    orderId: orderId.toString(),
    paymentType: PaymentType.DEPOSIT,
    amount: depositAmount
  });
}

private calculateDepositAmount(totalAmount: number): number {
  // å®šé‡‘è®¡ç®—é€»è¾‘ï¼Œä¾‹å¦‚30%æˆ–å›ºå®šé‡‘é¢
  return Math.min(totalAmount * 0.3, 500); // 30%ä¸”ä¸è¶…è¿‡500å…ƒ
}
```

#### 2. å…¨æ¬¾æ”¯ä»˜æµç¨‹
```typescript
// å…¨æ¬¾æ”¯ä»˜ä¸šåŠ¡é€»è¾‘
async processFullPayment(orderId: number): Promise<Payment> {
  const order = await this.getOrder(orderId);
  
  // æ£€æŸ¥æ˜¯å¦å·²æœ‰å®šé‡‘æ”¯ä»˜
  const existingPayments = await this.getOrderPayments(orderId);
  const paidAmount = existingPayments
    .filter(p => p.status === PaymentStatus.PAID)
    .reduce((sum, p) => sum + p.amount, 0);
  
  if (paidAmount >= order.totalAmount) {
    throw new BadRequestException('è®¢å•å·²å®Œæˆæ”¯ä»˜');
  }
  
  return await this.createPayment({
    orderId: orderId.toString(),
    paymentType: PaymentType.FULL_PAYMENT,
    amount: order.totalAmount - paidAmount
  });
}
```

#### 3. å°¾æ¬¾æ”¯ä»˜æµç¨‹
```typescript
// å°¾æ¬¾æ”¯ä»˜ä¸šåŠ¡é€»è¾‘
async processRemainingPayment(orderId: number): Promise<Payment> {
  const order = await this.getOrder(orderId);
  const existingPayments = await this.getOrderPayments(orderId);
  
  // æ£€æŸ¥æ˜¯å¦å·²æœ‰å®šé‡‘æ”¯ä»˜
  const depositPayment = existingPayments.find(
    p => p.paymentType === PaymentType.DEPOSIT && p.status === PaymentStatus.PAID
  );
  
  if (!depositPayment) {
    throw new BadRequestException('è¯·å…ˆå®Œæˆå®šé‡‘æ”¯ä»˜');
  }
  
  const remainingAmount = order.totalAmount - depositPayment.amount;
  
  return await this.createPayment({
    orderId: orderId.toString(),
    paymentType: PaymentType.REMAINING,
    amount: remainingAmount
  });
}
```

---

## çŠ¶æ€ç®¡ç†

### ğŸ”„ æ”¯ä»˜çŠ¶æ€æœº
```typescript
@Injectable()
export class PaymentStateMachineService {
  private readonly stateTransitions = {
    [PaymentStatus.CREATED]: [PaymentStatus.PAID, PaymentStatus.FAILED],
    [PaymentStatus.PAID]: [PaymentStatus.REFUNDED],
    [PaymentStatus.FAILED]: [PaymentStatus.CREATED], // å…è®¸é‡æ–°æ”¯ä»˜
    [PaymentStatus.REFUNDED]: [], // ç»ˆæ€
  };

  canTransition(from: PaymentStatus, to: PaymentStatus): boolean {
    return this.stateTransitions[from]?.includes(to) || false;
  }

  async transitionTo(paymentId: number, newStatus: PaymentStatus): Promise<Payment> {
    const payment = await this.paymentsService.findOne(paymentId);
    
    if (!this.canTransition(payment.status, newStatus)) {
      throw new BadRequestException(
        `Cannot transition from ${payment.status} to ${newStatus}`
      );
    }

    return await this.paymentsService.updateStatus(paymentId, newStatus);
  }

  async handlePaymentSuccess(paymentId: number, transactionId: string): Promise<void> {
    await this.prisma.$transaction(async (tx) => {
      // æ›´æ–°æ”¯ä»˜çŠ¶æ€
      await tx.payment.update({
        where: { id: paymentId },
        data: {
          status: PaymentStatus.PAID,
          transactionId,
          paidAt: new Date(),
        },
      });

      // æ›´æ–°è®¢å•æ”¯ä»˜çŠ¶æ€
      const payment = await tx.payment.findUnique({
        where: { id: paymentId },
        include: { order: true }
      });

      await this.updateOrderPaymentStatus(payment.orderId);
    });
  }

  private async updateOrderPaymentStatus(orderId: number): Promise<void> {
    const order = await this.prisma.order.findUnique({
      where: { id: orderId },
      include: { payments: true }
    });

    const totalPaid = order.payments
      .filter(p => p.status === PaymentStatus.PAID)
      .reduce((sum, p) => sum + p.amount, 0);

    let paymentStatus: string;
    if (totalPaid === 0) {
      paymentStatus = 'PENDING';
    } else if (totalPaid < order.totalAmount) {
      paymentStatus = 'PARTIAL_PAID';
    } else {
      paymentStatus = 'PAID';
    }

    await this.prisma.order.update({
      where: { id: orderId },
      data: { paymentStatus }
    });
  }
}
```

---

## æŠ€æœ¯å®ç°

### ğŸ”§ æ ¸å¿ƒæŠ€æœ¯æ ˆ
- **NestJS**: Webæ¡†æ¶å’Œä¾èµ–æ³¨å…¥
- **Prisma**: ORMæ•°æ®åº“è®¿é—®
- **TypeScript**: ç±»å‹å®‰å…¨
- **å¾®ä¿¡æ”¯ä»˜SDK**: å¾®ä¿¡æ”¯ä»˜æ¥å£é›†æˆ
- **æ”¯ä»˜å®SDK**: æ”¯ä»˜å®æ¥å£é›†æˆ
- **crypto**: åŠ å¯†å’Œç­¾åéªŒè¯

### ğŸ“‹ æ”¯ä»˜æœåŠ¡æ ¸å¿ƒå®ç°
```typescript
@Injectable()
export class PaymentsService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly paymentStateMachine: PaymentStateMachineService,
    private readonly wechatPayService: WechatPayService,
    private readonly alipayService: AlipayService,
  ) {}

  async create(createPaymentDto: CreatePaymentDto): Promise<Payment> {
    return await this.prisma.$transaction(async (tx) => {
      // 1. éªŒè¯è®¢å•å­˜åœ¨
      const order = await tx.order.findUnique({
        where: { id: parseInt(createPaymentDto.orderId) },
        include: {
          user: { select: { id: true, nickname: true, openid: true } },
          package: { select: { id: true, name: true, price: true } },
        },
      });

      if (!order) {
        throw new NotFoundException('è®¢å•ä¸å­˜åœ¨');
      }

      // 2. éªŒè¯æ”¯ä»˜é‡‘é¢
      await this.validatePaymentAmount(order, createPaymentDto);

      // 3. åˆ›å»ºæ”¯ä»˜è®°å½•
      const payment = await tx.payment.create({
        data: {
          orderId: parseInt(createPaymentDto.orderId),
          paymentType: createPaymentDto.paymentType,
          amount: createPaymentDto.amount,
          status: PaymentStatus.CREATED,
        },
        include: {
          order: {
            include: {
              user: { select: { id: true, nickname: true } },
              package: { select: { id: true, name: true } },
            },
          },
        },
      });

      // 4. è°ƒç”¨ç¬¬ä¸‰æ–¹æ”¯ä»˜æ¥å£
      const paymentInfo = await this.createThirdPartyPayment(payment);

      return {
        ...payment,
        ...paymentInfo,
      };
    });
  }

  private async validatePaymentAmount(
    order: any,
    createPaymentDto: CreatePaymentDto
  ): Promise<void> {
    const existingPayments = await this.prisma.payment.findMany({
      where: {
        orderId: order.id,
        status: PaymentStatus.PAID,
      },
    });

    const totalPaid = existingPayments.reduce((sum, p) => sum + p.amount, 0);
    const remainingAmount = order.totalAmount - totalPaid;

    if (createPaymentDto.amount > remainingAmount) {
      throw new BadRequestException('æ”¯ä»˜é‡‘é¢è¶…è¿‡è®¢å•å‰©ä½™é‡‘é¢');
    }

    if (createPaymentDto.amount <= 0) {
      throw new BadRequestException('æ”¯ä»˜é‡‘é¢å¿…é¡»å¤§äº0');
    }
  }

  private async createThirdPartyPayment(payment: Payment): Promise<any> {
    const { order } = payment;
    
    // æ ¹æ®ç”¨æˆ·ç±»å‹é€‰æ‹©æ”¯ä»˜æ–¹å¼ï¼ˆè¿™é‡Œé»˜è®¤å¾®ä¿¡æ”¯ä»˜ï¼‰
    const paymentRequest = {
      out_trade_no: `PAY_${payment.id}_${Date.now()}`,
      total_fee: Math.round(payment.amount * 100), // è½¬ä¸ºåˆ†
      body: `${order.package.name} - ${payment.paymentType}`,
      openid: order.user.openid,
    };

    try {
      const result = await this.wechatPayService.createOrder(paymentRequest);
      
      return {
        paymentUrl: result.code_url,
        qrCode: await this.generateQRCode(result.code_url),
        platformType: PlatformType.WECHAT,
      };
    } catch (error) {
      throw new BadRequestException(`åˆ›å»ºæ”¯ä»˜è®¢å•å¤±è´¥: ${error.message}`);
    }
  }

  async handlePaymentCallback(callbackData: any): Promise<void> {
    try {
      // 1. éªŒè¯å›è°ƒç­¾å
      const isValid = await this.wechatPayService.verifyCallback(callbackData);
      if (!isValid) {
        throw new BadRequestException('å›è°ƒç­¾åéªŒè¯å¤±è´¥');
      }

      // 2. è§£ææ”¯ä»˜ç»“æœ
      const { out_trade_no, transaction_id, result_code } = callbackData;
      const paymentId = this.extractPaymentIdFromTradeNo(out_trade_no);

      // 3. æ›´æ–°æ”¯ä»˜çŠ¶æ€
      if (result_code === 'SUCCESS') {
        await this.paymentStateMachine.handlePaymentSuccess(paymentId, transaction_id);
      } else {
        await this.updatePaymentStatus(paymentId, PaymentStatus.FAILED);
      }
    } catch (error) {
      console.error('æ”¯ä»˜å›è°ƒå¤„ç†å¤±è´¥:', error);
      throw error;
    }
  }

  async processRefund(paymentId: number, refundAmount?: number): Promise<void> {
    const payment = await this.findOne(paymentId);
    
    if (payment.status !== PaymentStatus.PAID) {
      throw new BadRequestException('åªèƒ½é€€æ¬¾å·²æ”¯ä»˜çš„è®¢å•');
    }

    const actualRefundAmount = refundAmount || payment.amount;
    
    if (actualRefundAmount > payment.amount) {
      throw new BadRequestException('é€€æ¬¾é‡‘é¢ä¸èƒ½è¶…è¿‡æ”¯ä»˜é‡‘é¢');
    }

    try {
      const refundRequest = {
        out_trade_no: `PAY_${payment.id}_${Date.now()}`,
        out_refund_no: `REFUND_${payment.id}_${Date.now()}`,
        total_fee: Math.round(payment.amount * 100),
        refund_fee: Math.round(actualRefundAmount * 100),
      };

      const result = await this.wechatPayService.refund(refundRequest);
      
      if (result.result_code === 'SUCCESS') {
        await this.updatePaymentStatus(paymentId, PaymentStatus.REFUNDED);
      }
    } catch (error) {
      throw new BadRequestException(`é€€æ¬¾å¤„ç†å¤±è´¥: ${error.message}`);
    }
  }
}
```

---

## ç¬¬ä¸‰æ–¹é›†æˆ

### ğŸ”Œ å¾®ä¿¡æ”¯ä»˜é›†æˆ
```typescript
@Injectable()
export class WechatPayService {
  private readonly appId: string;
  private readonly mchId: string;
  private readonly apiKey: string;
  private readonly notifyUrl: string;

  constructor(private readonly configService: ConfigService) {
    this.appId = configService.get('WECHAT_APP_ID');
    this.mchId = configService.get('WECHAT_MCH_ID');
    this.apiKey = configService.get('WECHAT_API_KEY');
    this.notifyUrl = configService.get('WECHAT_NOTIFY_URL');
  }

  async createOrder(orderData: WechatPayOrderRequest): Promise<WechatPayOrderResponse> {
    const params = {
      appid: this.appId,
      mch_id: this.mchId,
      nonce_str: this.generateNonceStr(),
      body: orderData.body,
      out_trade_no: orderData.out_trade_no,
      total_fee: orderData.total_fee,
      spbill_create_ip: '127.0.0.1',
      notify_url: this.notifyUrl,
      trade_type: 'NATIVE', // æ‰«ç æ”¯ä»˜
    };

    // ç”Ÿæˆç­¾å
    params.sign = this.generateSign(params);

    // è°ƒç”¨å¾®ä¿¡æ”¯ä»˜API
    const xml = this.objectToXml(params);
    const response = await this.httpPost('https://api.mch.weixin.qq.com/pay/unifiedorder', xml);
    
    return this.xmlToObject(response);
  }

  async verifyCallback(callbackData: any): Promise<boolean> {
    const { sign, ...params } = callbackData;
    const expectedSign = this.generateSign(params);
    
    return sign === expectedSign;
  }

  async refund(refundData: WechatRefundRequest): Promise<WechatRefundResponse> {
    const params = {
      appid: this.appId,
      mch_id: this.mchId,
      nonce_str: this.generateNonceStr(),
      out_trade_no: refundData.out_trade_no,
      out_refund_no: refundData.out_refund_no,
      total_fee: refundData.total_fee,
      refund_fee: refundData.refund_fee,
    };

    params.sign = this.generateSign(params);

    const xml = this.objectToXml(params);
    const response = await this.httpPost('https://api.mch.weixin.qq.com/secapi/pay/refund', xml);
    
    return this.xmlToObject(response);
  }

  private generateSign(params: any): string {
    const sortedParams = Object.keys(params)
      .filter(key => params[key] !== '' && key !== 'sign')
      .sort()
      .map(key => `${key}=${params[key]}`)
      .join('&');
    
    const stringToSign = `${sortedParams}&key=${this.apiKey}`;
    
    return crypto.createHash('md5').update(stringToSign, 'utf8').digest('hex').toUpperCase();
  }

  private generateNonceStr(): string {
    return crypto.randomBytes(16).toString('hex');
  }

  private objectToXml(obj: any): string {
    let xml = '<xml>';
    for (const key in obj) {
      xml += `<${key}><![CDATA[${obj[key]}]]></${key}>`;
    }
    xml += '</xml>';
    return xml;
  }

  private xmlToObject(xml: string): any {
    // XMLè§£æå®ç°
    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­å»ºè®®ä½¿ç”¨xml2jsç­‰åº“
    const result = {};
    const regex = /<(\w+)><!\[CDATA\[(.*?)\]\]><\/\1>/g;
    let match;
    
    while ((match = regex.exec(xml)) !== null) {
      result[match[1]] = match[2];
    }
    
    return result;
  }

  private async httpPost(url: string, data: string): Promise<string> {
    // HTTPè¯·æ±‚å®ç°
    // è¿™é‡Œéœ€è¦ä½¿ç”¨node.jsçš„httpæ¨¡å—æˆ–axiosç­‰åº“
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/xml' },
      body: data,
    });
    
    return response.text();
  }
}
```

### ğŸ’° æ”¯ä»˜å®é›†æˆ
```typescript
@Injectable()
export class AlipayService {
  private readonly appId: string;
  private readonly privateKey: string;
  private readonly alipayPublicKey: string;
  private readonly gatewayUrl: string;

  constructor(private readonly configService: ConfigService) {
    this.appId = configService.get('ALIPAY_APP_ID');
    this.privateKey = configService.get('ALIPAY_PRIVATE_KEY');
    this.alipayPublicKey = configService.get('ALIPAY_PUBLIC_KEY');
    this.gatewayUrl = 'https://openapi.alipay.com/gateway.do';
  }

  async createOrder(orderData: AlipayOrderRequest): Promise<AlipayOrderResponse> {
    const params = {
      app_id: this.appId,
      method: 'alipay.trade.precreate',
      charset: 'utf-8',
      sign_type: 'RSA2',
      timestamp: new Date().toISOString().replace('T', ' ').substring(0, 19),
      version: '1.0',
      biz_content: JSON.stringify({
        out_trade_no: orderData.out_trade_no,
        total_amount: orderData.total_amount,
        subject: orderData.subject,
      }),
    };

    // ç”Ÿæˆç­¾å
    params.sign = this.generateSign(params);

    // è°ƒç”¨æ”¯ä»˜å®API
    const response = await this.httpPost(this.gatewayUrl, params);
    
    return JSON.parse(response);
  }

  async verifyCallback(callbackData: any): Promise<boolean> {
    const { sign, sign_type, ...params } = callbackData;
    
    // å‚æ•°æ’åºå’Œæ‹¼æ¥
    const sortedParams = Object.keys(params)
      .sort()
      .map(key => `${key}=${params[key]}`)
      .join('&');

    // éªŒè¯ç­¾å
    const verify = crypto.createVerify('RSA-SHA256');
    verify.update(sortedParams, 'utf8');
    
    return verify.verify(this.alipayPublicKey, sign, 'base64');
  }

  private generateSign(params: any): string {
    const sortedParams = Object.keys(params)
      .filter(key => params[key] !== '' && key !== 'sign')
      .sort()
      .map(key => `${key}=${params[key]}`)
      .join('&');

    const sign = crypto.createSign('RSA-SHA256');
    sign.update(sortedParams, 'utf8');
    
    return sign.sign(this.privateKey, 'base64');
  }

  private async httpPost(url: string, params: any): Promise<string> {
    const queryString = new URLSearchParams(params).toString();
    
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: queryString,
    });
    
    return response.text();
  }
}
```

---

## ä½¿ç”¨ç¤ºä¾‹

### ğŸ¯ å‰ç«¯é›†æˆç¤ºä¾‹

#### å¾®ä¿¡å°ç¨‹åºæ”¯ä»˜é›†æˆ
```javascript
// æ”¯ä»˜é¡µé¢
Page({
  data: {
    order: null,
    paymentType: 'DEPOSIT', // DEPOSIT, FULL_PAYMENT, REMAINING
    paymentAmount: 0,
    loading: false
  },

  onLoad(options) {
    const orderId = options.orderId;
    this.loadOrderInfo(orderId);
  },

  async loadOrderInfo(orderId) {
    try {
      const res = await wx.request({
        url: `https://api.example.com/orders/${orderId}`,
        method: 'GET'
      });

      const order = res.data;
      const depositAmount = order.totalAmount * 0.3; // 30%å®šé‡‘

      this.setData({
        order,
        paymentAmount: this.data.paymentType === 'DEPOSIT' ? depositAmount : order.totalAmount
      });
    } catch (error) {
      wx.showToast({ title: 'åŠ è½½è®¢å•å¤±è´¥', icon: 'error' });
    }
  },

  onPaymentTypeChange(e) {
    const paymentType = e.detail.value;
    const { order } = this.data;
    
    let paymentAmount = 0;
    if (paymentType === 'DEPOSIT') {
      paymentAmount = order.totalAmount * 0.3;
    } else if (paymentType === 'FULL_PAYMENT') {
      paymentAmount = order.totalAmount;
    } else if (paymentType === 'REMAINING') {
      // è®¡ç®—å°¾æ¬¾é‡‘é¢
      paymentAmount = this.calculateRemainingAmount(order);
    }

    this.setData({
      paymentType,
      paymentAmount
    });
  },

  async createPayment() {
    if (this.data.loading) return;

    this.setData({ loading: true });

    try {
      // 1. åˆ›å»ºæ”¯ä»˜è®°å½•
      const paymentRes = await wx.request({
        url: 'https://api.example.com/payments',
        method: 'POST',
        data: {
          orderId: this.data.order.id.toString(),
          paymentType: this.data.paymentType,
          amount: this.data.paymentAmount
        }
      });

      const payment = paymentRes.data;

      // 2. è°ƒç”¨å¾®ä¿¡æ”¯ä»˜
      const paymentResult = await wx.requestPayment({
        timeStamp: payment.timeStamp,
        nonceStr: payment.nonceStr,
        package: payment.package,
        signType: 'MD5',
        paySign: payment.paySign
      });

      // 3. æ”¯ä»˜æˆåŠŸå¤„ç†
      wx.showToast({ title: 'æ”¯ä»˜æˆåŠŸ', icon: 'success' });
      
      // è·³è½¬åˆ°æ”¯ä»˜ç»“æœé¡µ
      wx.redirectTo({
        url: `/pages/payment-result/payment-result?paymentId=${payment.id}&status=success`
      });

    } catch (error) {
      if (error.errMsg === 'requestPayment:fail cancel') {
        wx.showToast({ title: 'æ”¯ä»˜å·²å–æ¶ˆ', icon: 'none' });
      } else {
        wx.showToast({ title: 'æ”¯ä»˜å¤±è´¥', icon: 'error' });
      }
    } finally {
      this.setData({ loading: false });
    }
  },

  calculateRemainingAmount(order) {
    // è®¡ç®—å°¾æ¬¾ï¼šæ€»é‡‘é¢ - å·²æ”¯ä»˜é‡‘é¢
    const paidAmount = order.payments
      .filter(p => p.status === 'PAID')
      .reduce((sum, p) => sum + p.amount, 0);
    
    return order.totalAmount - paidAmount;
  }
});
```

#### React æ”¯ä»˜ç»„ä»¶
```typescript
// æ”¯ä»˜æœåŠ¡ç±»
class PaymentService {
  private baseURL = '/api/payments';

  async createPayment(paymentData: CreatePaymentDto): Promise<Payment> {
    const response = await fetch(this.baseURL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(paymentData),
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'åˆ›å»ºæ”¯ä»˜å¤±è´¥');
    }
    
    return response.json();
  }

  async getOrderPayments(orderId: number): Promise<Payment[]> {
    const response = await fetch(`${this.baseURL}/order/${orderId}`);
    if (!response.ok) throw new Error('è·å–æ”¯ä»˜è®°å½•å¤±è´¥');
    return response.json();
  }

  async checkPaymentStatus(paymentId: number): Promise<Payment> {
    const response = await fetch(`${this.baseURL}/${paymentId}`);
    if (!response.ok) throw new Error('æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€å¤±è´¥');
    return response.json();
  }
}

// React Hook
function usePayment(orderId: number) {
  const [payments, setPayments] = useState<Payment[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const paymentService = new PaymentService();

  const fetchPayments = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const data = await paymentService.getOrderPayments(orderId);
      setPayments(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'è·å–æ”¯ä»˜è®°å½•å¤±è´¥');
    } finally {
      setLoading(false);
    }
  }, [orderId]);

  useEffect(() => {
    if (orderId) {
      fetchPayments();
    }
  }, [orderId, fetchPayments]);

  const createPayment = async (paymentData: CreatePaymentDto) => {
    try {
      const newPayment = await paymentService.createPayment(paymentData);
      setPayments(prev => [newPayment, ...prev]);
      return newPayment;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'åˆ›å»ºæ”¯ä»˜å¤±è´¥');
      throw err;
    }
  };

  const checkPaymentStatus = async (paymentId: number) => {
    try {
      const updatedPayment = await paymentService.checkPaymentStatus(paymentId);
      setPayments(prev => prev.map(p => 
        p.id === paymentId ? updatedPayment : p
      ));
      return updatedPayment;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'æŸ¥è¯¢çŠ¶æ€å¤±è´¥');
      throw err;
    }
  };

  return {
    payments,
    loading,
    error,
    createPayment,
    checkPaymentStatus,
    refresh: fetchPayments,
  };
}

// æ”¯ä»˜ç»„ä»¶
function PaymentComponent({ order }: { order: Order }) {
  const { payments, createPayment, checkPaymentStatus } = usePayment(order.id);
  const [selectedPaymentType, setSelectedPaymentType] = useState<PaymentType>('DEPOSIT');
  const [processing, setProcessing] = useState(false);

  const calculatePaymentAmount = (type: PaymentType): number => {
    const paidAmount = payments
      .filter(p => p.status === 'PAID')
      .reduce((sum, p) => sum + p.amount, 0);

    switch (type) {
      case 'DEPOSIT':
        return order.totalAmount * 0.3; // 30%å®šé‡‘
      case 'FULL_PAYMENT':
        return order.totalAmount - paidAmount;
      case 'REMAINING':
        return order.totalAmount - paidAmount;
      default:
        return 0;
    }
  };

  const handlePayment = async () => {
    if (processing) return;

    setProcessing(true);

    try {
      const paymentAmount = calculatePaymentAmount(selectedPaymentType);
      
      if (paymentAmount <= 0) {
        alert('æ”¯ä»˜é‡‘é¢å¿…é¡»å¤§äº0');
        return;
      }

      // åˆ›å»ºæ”¯ä»˜è®°å½•
      const payment = await createPayment({
        orderId: order.id.toString(),
        paymentType: selectedPaymentType,
        amount: paymentAmount,
      });

      // æ¨¡æ‹Ÿæ”¯ä»˜æµç¨‹ï¼ˆå®é™…åº”ç”¨ä¸­ä¼šè·³è½¬åˆ°æ”¯ä»˜é¡µé¢ï¼‰
      const paymentSuccess = await simulatePayment(payment);

      if (paymentSuccess) {
        // æ£€æŸ¥æ”¯ä»˜çŠ¶æ€æ›´æ–°
        await checkPaymentStatus(payment.id);
        alert('æ”¯ä»˜æˆåŠŸï¼');
      } else {
        alert('æ”¯ä»˜å¤±è´¥ï¼Œè¯·é‡è¯•');
      }
    } catch (error) {
      alert(`æ”¯ä»˜å¤±è´¥: ${error.message}`);
    } finally {
      setProcessing(false);
    }
  };

  const simulatePayment = (payment: Payment): Promise<boolean> => {
    return new Promise((resolve) => {
      // æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†æ—¶é—´
      setTimeout(() => {
        resolve(Math.random() > 0.1); // 90%æˆåŠŸç‡
      }, 2000);
    });
  };

  const getPaymentTypeText = (type: PaymentType): string => {
    const texts = {
      DEPOSIT: 'å®šé‡‘æ”¯ä»˜',
      FULL_PAYMENT: 'å…¨æ¬¾æ”¯ä»˜',
      REMAINING: 'å°¾æ¬¾æ”¯ä»˜',
    };
    return texts[type];
  };

  const getStatusText = (status: PaymentStatus): string => {
    const texts = {
      CREATED: 'ç­‰å¾…æ”¯ä»˜',
      PAID: 'å·²æ”¯ä»˜',
      FAILED: 'æ”¯ä»˜å¤±è´¥',
      REFUNDED: 'å·²é€€æ¬¾',
    };
    return texts[status];
  };

  return (
    <div className="payment-component">
      <div className="order-info">
        <h3>è®¢å•ä¿¡æ¯</h3>
        <p>è®¢å•å·: {order.orderNo}</p>
        <p>å¥—é¤: {order.package.name}</p>
        <p>æ€»é‡‘é¢: Â¥{order.totalAmount}</p>
      </div>

      <div className="payment-history">
        <h4>æ”¯ä»˜è®°å½•</h4>
        {payments.length === 0 ? (
          <p>æš‚æ— æ”¯ä»˜è®°å½•</p>
        ) : (
          <div className="payment-list">
            {payments.map(payment => (
              <div key={payment.id} className="payment-item">
                <span>{getPaymentTypeText(payment.paymentType)}</span>
                <span>Â¥{payment.amount}</span>
                <span className={`status ${payment.status.toLowerCase()}`}>
                  {getStatusText(payment.status)}
                </span>
                {payment.paidAt && (
                  <span>{format(new Date(payment.paidAt), 'yyyy-MM-dd HH:mm')}</span>
                )}
              </div>
            ))}
          </div>
        )}
      </div>

      <div className="payment-form">
        <h4>æ–°å»ºæ”¯ä»˜</h4>
        
        <div className="payment-type-selector">
          <label>
            <input
              type="radio"
              value="DEPOSIT"
              checked={selectedPaymentType === 'DEPOSIT'}
              onChange={(e) => setSelectedPaymentType(e.target.value as PaymentType)}
            />
            å®šé‡‘æ”¯ä»˜ (30%)
          </label>
          <label>
            <input
              type="radio"
              value="FULL_PAYMENT"
              checked={selectedPaymentType === 'FULL_PAYMENT'}
              onChange={(e) => setSelectedPaymentType(e.target.value as PaymentType)}
            />
            å…¨æ¬¾æ”¯ä»˜
          </label>
          <label>
            <input
              type="radio"
              value="REMAINING"
              checked={selectedPaymentType === 'REMAINING'}
              onChange={(e) => setSelectedPaymentType(e.target.value as PaymentType)}
            />
            å°¾æ¬¾æ”¯ä»˜
          </label>
        </div>

        <div className="payment-amount">
          æ”¯ä»˜é‡‘é¢: Â¥{calculatePaymentAmount(selectedPaymentType)}
        </div>

        <button
          className="pay-button"
          onClick={handlePayment}
          disabled={processing || calculatePaymentAmount(selectedPaymentType) <= 0}
        >
          {processing ? 'å¤„ç†ä¸­...' : 'ç«‹å³æ”¯ä»˜'}
        </button>
      </div>
    </div>
  );
}
```

---

## å®‰å…¨æœºåˆ¶

### ğŸ” æ•°æ®å®‰å…¨
```typescript
// æ•æ„Ÿæ•°æ®åŠ å¯†æœåŠ¡
@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly secretKey: string;

  constructor(private readonly configService: ConfigService) {
    this.secretKey = configService.get('ENCRYPTION_SECRET_KEY');
  }

  encrypt(text: string): { encrypted: string; iv: string; tag: string } {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.secretKey);
    cipher.setAAD(Buffer.from('payment', 'utf8'));

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const tag = cipher.getAuthTag();

    return {
      encrypted,
      iv: iv.toString('hex'),
      tag: tag.toString('hex'),
    };
  }

  decrypt(encrypted: string, iv: string, tag: string): string {
    const decipher = crypto.createDecipher(this.algorithm, this.secretKey);
    decipher.setAAD(Buffer.from('payment', 'utf8'));
    decipher.setAuthTag(Buffer.from(tag, 'hex'));

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}

// æ”¯ä»˜æ•°æ®å®‰å…¨å¤„ç†
@Injectable()
export class PaymentSecurityService {
  constructor(private readonly encryptionService: EncryptionService) {}

  async secureSavePayment(paymentData: any): Promise<Payment> {
    // åŠ å¯†æ•æ„Ÿå­—æ®µ
    if (paymentData.transactionId) {
      const encrypted = this.encryptionService.encrypt(paymentData.transactionId);
      paymentData.encryptedTransactionId = JSON.stringify(encrypted);
      delete paymentData.transactionId; // åˆ é™¤æ˜æ–‡
    }

    return await this.prisma.payment.create({ data: paymentData });
  }

  async secureGetPayment(paymentId: number): Promise<Payment> {
    const payment = await this.prisma.payment.findUnique({
      where: { id: paymentId }
    });

    // è§£å¯†æ•æ„Ÿå­—æ®µ
    if (payment.encryptedTransactionId) {
      const encryptedData = JSON.parse(payment.encryptedTransactionId);
      payment.transactionId = this.encryptionService.decrypt(
        encryptedData.encrypted,
        encryptedData.iv,
        encryptedData.tag
      );
    }

    return payment;
  }
}
```

### ğŸ›¡ï¸ é˜²é‡å¤æ”¯ä»˜
```typescript
@Injectable()
export class PaymentDeduplicationService {
  private readonly redis: Redis;

  constructor(
    @Inject('REDIS_CLIENT') redis: Redis,
    private readonly prisma: PrismaService,
  ) {
    this.redis = redis;
  }

  async checkAndLockPayment(orderId: number, paymentType: PaymentType): Promise<string> {
    const lockKey = `payment_lock:${orderId}:${paymentType}`;
    const lockValue = `${Date.now()}_${Math.random()}`;
    const lockExpire = 300; // 5åˆ†é’Ÿé”å®šæ—¶é—´

    // å°è¯•è·å–é”
    const result = await this.redis.set(lockKey, lockValue, 'EX', lockExpire, 'NX');
    
    if (!result) {
      throw new ConflictException('æ”¯ä»˜æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨åå†è¯•');
    }

    // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒç±»å‹çš„æ”¯ä»˜è®°å½•
    const existingPayment = await this.prisma.payment.findFirst({
      where: {
        orderId,
        paymentType,
        status: { in: ['CREATED', 'PAID'] },
      },
    });

    if (existingPayment) {
      // é‡Šæ”¾é”
      await this.releaseLock(lockKey, lockValue);
      throw new ConflictException('å·²å­˜åœ¨ç›¸åŒç±»å‹çš„æ”¯ä»˜è®°å½•');
    }

    return lockValue;
  }

  async releaseLock(lockKey: string, lockValue: string): Promise<void> {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;

    await this.redis.eval(script, 1, lockKey, lockValue);
  }

  async processPaymentWithLock(
    orderId: number,
    paymentType: PaymentType,
    amount: number,
    lockValue: string,
  ): Promise<Payment> {
    const lockKey = `payment_lock:${orderId}:${paymentType}`;

    try {
      // åˆ›å»ºæ”¯ä»˜è®°å½•
      const payment = await this.prisma.payment.create({
        data: {
          orderId,
          paymentType,
          amount,
          status: PaymentStatus.CREATED,
        },
      });

      return payment;
    } finally {
      // ç¡®ä¿é‡Šæ”¾é”
      await this.releaseLock(lockKey, lockValue);
    }
  }
}
```

---

## å¸¸è§é—®é¢˜

### â“ FAQ

#### Q1: å¦‚ä½•å¤„ç†æ”¯ä»˜å›è°ƒçš„å¹‚ç­‰æ€§ï¼Ÿ
**A**: ä½¿ç”¨Redisç¼“å­˜å›è°ƒå¤„ç†çŠ¶æ€ï¼Œç¡®ä¿ç›¸åŒå›è°ƒåªå¤„ç†ä¸€æ¬¡ã€‚

```typescript
async handlePaymentCallbackIdempotent(callbackData: any): Promise<void> {
  const { transaction_id } = callbackData;
  const cacheKey = `payment_callback:${transaction_id}`;
  
  // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
  const processed = await this.redis.get(cacheKey);
  if (processed) {
    return; // å·²å¤„ç†ï¼Œç›´æ¥è¿”å›
  }

  // è®¾ç½®å¤„ç†æ ‡è®°ï¼Œæœ‰æ•ˆæœŸ24å°æ—¶
  await this.redis.setex(cacheKey, 86400, 'processed');

  try {
    await this.handlePaymentCallback(callbackData);
  } catch (error) {
    // å¤„ç†å¤±è´¥ï¼Œåˆ é™¤æ ‡è®°
    await this.redis.del(cacheKey);
    throw error;
  }
}
```

#### Q2: å¦‚ä½•å®ç°æ”¯ä»˜è¶…æ—¶è‡ªåŠ¨å–æ¶ˆï¼Ÿ
**A**: ä½¿ç”¨å®šæ—¶ä»»åŠ¡æ£€æŸ¥è¶…æ—¶æ”¯ä»˜å¹¶è‡ªåŠ¨å–æ¶ˆã€‚

```typescript
@Cron('0 */5 * * * *') // æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
async cancelTimeoutPayments(): Promise<void> {
  const timeoutPayments = await this.prisma.payment.findMany({
    where: {
      status: PaymentStatus.CREATED,
      createdAt: {
        lte: new Date(Date.now() - 30 * 60 * 1000), // 30åˆ†é’Ÿå‰
      },
    },
  });

  for (const payment of timeoutPayments) {
    await this.updatePaymentStatus(payment.id, PaymentStatus.FAILED);
  }
}
```

#### Q3: å¦‚ä½•å¤„ç†éƒ¨åˆ†é€€æ¬¾åœºæ™¯ï¼Ÿ
**A**: åˆ›å»ºè´Ÿé‡‘é¢çš„é€€æ¬¾è®°å½•ï¼Œè·Ÿè¸ªé€€æ¬¾å†å²ã€‚

```typescript
async processPartialRefund(
  originalPaymentId: number,
  refundAmount: number,
  reason: string
): Promise<Payment> {
  const originalPayment = await this.findOne(originalPaymentId);
  
  // åˆ›å»ºé€€æ¬¾è®°å½•
  const refundPayment = await this.prisma.payment.create({
    data: {
      orderId: originalPayment.orderId,
      paymentType: originalPayment.paymentType,
      amount: -refundAmount, // è´Ÿæ•°è¡¨ç¤ºé€€æ¬¾
      status: PaymentStatus.CREATED,
      relatedPaymentId: originalPaymentId, // å…³è”åŸæ”¯ä»˜è®°å½•
      refundReason: reason,
    },
  });

  // è°ƒç”¨ç¬¬ä¸‰æ–¹é€€æ¬¾æ¥å£
  await this.processThirdPartyRefund(refundPayment);

  return refundPayment;
}
```

#### Q4: å¦‚ä½•å®ç°æ”¯ä»˜æ•°æ®çš„å®¡è®¡æ—¥å¿—ï¼Ÿ
**A**: åˆ›å»ºæ”¯ä»˜æ“ä½œå®¡è®¡è¡¨ï¼Œè®°å½•æ‰€æœ‰å…³é”®æ“ä½œã€‚

```typescript
// æ”¯ä»˜å®¡è®¡æ¨¡å‹
model PaymentAudit {
  id          Int      @id @default(autoincrement())
  paymentId   Int
  action      String   // CREATE, UPDATE, REFUND, CANCEL
  oldData     Json?    // æ“ä½œå‰æ•°æ®
  newData     Json?    // æ“ä½œåæ•°æ®
  operatorId  Int?     // æ“ä½œäººID
  operatorType String  // USER, SYSTEM, ADMIN
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())
}

// å®¡è®¡æœåŠ¡
@Injectable()
export class PaymentAuditService {
  async logPaymentAction(
    paymentId: number,
    action: string,
    oldData: any,
    newData: any,
    context: any
  ): Promise<void> {
    await this.prisma.paymentAudit.create({
      data: {
        paymentId,
        action,
        oldData,
        newData,
        operatorId: context.userId,
        operatorType: context.userType || 'SYSTEM',
        ipAddress: context.ip,
        userAgent: context.userAgent,
      },
    });
  }
}
```

#### Q5: å¦‚ä½•å®ç°æ”¯ä»˜çš„é£æ§æ£€æŸ¥ï¼Ÿ
**A**: åœ¨æ”¯ä»˜åˆ›å»ºå‰è¿›è¡Œé£é™©è¯„ä¼°å’Œæ£€æŸ¥ã€‚

```typescript
@Injectable()
export class PaymentRiskControlService {
  async checkPaymentRisk(
    userId: number,
    amount: number,
    paymentType: PaymentType
  ): Promise<RiskCheckResult> {
    const risks = [];

    // 1. æ£€æŸ¥ç”¨æˆ·æ”¯ä»˜é¢‘ç‡
    const recentPayments = await this.getRecentPayments(userId, 24); // 24å°æ—¶å†…
    if (recentPayments.length > 10) {
      risks.push('æ”¯ä»˜é¢‘ç‡è¿‡é«˜');
    }

    // 2. æ£€æŸ¥æ”¯ä»˜é‡‘é¢å¼‚å¸¸
    const avgAmount = await this.getUserAveragePaymentAmount(userId);
    if (amount > avgAmount * 5) {
      risks.push('æ”¯ä»˜é‡‘é¢å¼‚å¸¸');
    }

    // 3. æ£€æŸ¥é»‘åå•
    const isBlacklisted = await this.checkUserBlacklist(userId);
    if (isBlacklisted) {
      risks.push('ç”¨æˆ·åœ¨é»‘åå•ä¸­');
    }

    return {
      isRisky: risks.length > 0,
      riskLevel: this.calculateRiskLevel(risks),
      risks,
      needManualReview: risks.length >= 2,
    };
  }

  async processPaymentWithRiskCheck(createPaymentDto: CreatePaymentDto): Promise<Payment> {
    const order = await this.getOrder(parseInt(createPaymentDto.orderId));
    const riskResult = await this.checkPaymentRisk(
      order.userId,
      createPaymentDto.amount,
      createPaymentDto.paymentType
    );

    if (riskResult.needManualReview) {
      // åˆ›å»ºå¾…å®¡æ ¸çš„æ”¯ä»˜è®°å½•
      return await this.createPendingReviewPayment(createPaymentDto, riskResult);
    }

    if (riskResult.isRisky) {
      // è®°å½•é£é™©æ—¥å¿—ä½†å…è®¸æ”¯ä»˜
      await this.logPaymentRisk(createPaymentDto, riskResult);
    }

    return await this.create(createPaymentDto);
  }
}
```

---

## æ€»ç»“

æ”¯ä»˜æ¨¡å—æ˜¯æ•´ä¸ªå©´å„¿æ‘„å½±å·¥ä½œå®¤ç³»ç»Ÿçš„å…³é”®è´¢åŠ¡æ¨¡å—ï¼Œæä¾›äº†ï¼š

âœ… **å®Œæ•´çš„æ”¯ä»˜æµç¨‹ç®¡ç†**: ä»åˆ›å»ºåˆ°å®Œæˆçš„å…¨æµç¨‹æ§åˆ¶  
âœ… **å¤šç§æ”¯ä»˜æ–¹å¼æ”¯æŒ**: å®šé‡‘ã€å…¨æ¬¾ã€å°¾æ¬¾ç­‰çµæ´»æ”¯ä»˜é€‰é¡¹  
âœ… **ä¸¥æ ¼çš„çŠ¶æ€ç®¡ç†**: åŸºäºçŠ¶æ€æœºçš„æ”¯ä»˜çŠ¶æ€æµè½¬æ§åˆ¶  
âœ… **å®‰å…¨çš„æ”¯ä»˜ä¿éšœ**: åŠ å¯†å­˜å‚¨ã€ç­¾åéªŒè¯ã€é˜²é‡å¤æ”¯ä»˜ç­‰å®‰å…¨æœºåˆ¶  
âœ… **å®Œå–„çš„ç¬¬ä¸‰æ–¹é›†æˆ**: å¾®ä¿¡æ”¯ä»˜ã€æ”¯ä»˜å®ç­‰ä¸»æµæ”¯ä»˜å¹³å°é›†æˆ  
âœ… **è¯¦ç»†çš„å®¡è®¡è¿½è¸ª**: å®Œæ•´çš„æ”¯ä»˜æ“ä½œæ—¥å¿—å’Œæ•°æ®å®¡è®¡  
âœ… **æ™ºèƒ½çš„é£æ§æ£€æŸ¥**: å¤šç»´åº¦çš„æ”¯ä»˜é£é™©è¯„ä¼°å’Œæ§åˆ¶  

è¯¥æ¨¡å—ä¸ºæ•´ä¸ªä¸šåŠ¡ç³»ç»Ÿæä¾›äº†å®‰å…¨ã€å¯é ã€çµæ´»çš„æ”¯ä»˜è§£å†³æ–¹æ¡ˆï¼Œæ»¡è¶³å„ç§æ”¯ä»˜åœºæ™¯å’Œä¸šåŠ¡éœ€æ±‚ã€‚

---

*æ–‡æ¡£ç‰ˆæœ¬: 1.0.0*  
*æœ€åæ›´æ–°: 2024å¹´7æœˆ25æ—¥*  
*ç»´æŠ¤è€…: å¼€å‘å›¢é˜Ÿ*

# 👤 用户模块功能说明文档

## 目录
- [模块概述](#模块概述)
- [系统架构](#系统架构)
- [核心功能](#核心功能)
- [API 接口详情](#api-接口详情)
- [数据模型](#数据模型)
- [业务逻辑](#业务逻辑)
- [技术实现](#技术实现)
- [使用示例](#使用示例)
- [安全特性](#安全特性)
- [常见问题](#常见问题)

---

## 模块概述

### 🎯 功能定位
用户模块是婴儿摄影工作室系统的基础模块，负责管理所有用户的基本信息。该模块主要处理微信小程序用户的注册、登录、信息管理等核心功能，为整个预约系统提供用户身份认证和基础数据支持。

### 🚀 主要特性
- **微信集成**: 支持微信小程序用户openid认证
- **完整的用户管理**: 创建、查询、更新、删除用户信息
- **灵活的数据结构**: 支持可选字段，适应不同场景需求
- **类型安全**: 完整的TypeScript类型定义和验证
- **RESTful API**: 标准的REST接口设计
- **Swagger文档**: 完整的API文档支持

### 📊 业务价值
- 统一用户身份管理，支持微信生态集成
- 提供用户画像基础数据支持
- 支持个性化服务和客户关系管理
- 为订单和支付提供用户关联基础
- 便于用户行为分析和业务优化

---

## 系统架构

### 🏗️ 模块结构
```
src/modules/users/
├── dto/
│   ├── create-user.dto.ts     # 创建用户DTO
│   └── update-user.dto.ts     # 更新用户DTO
├── users.controller.ts        # 用户控制器
├── users.service.ts           # 用户服务
└── users.module.ts            # 用户模块
```

### 🔄 架构层次
1. **控制器层**: 处理HTTP请求，参数验证，响应格式化
2. **服务层**: 业务逻辑处理，数据验证，异常处理
3. **数据访问层**: 通过Prisma进行数据库操作
4. **DTO层**: 数据传输对象，确保类型安全和验证

### 🔗 依赖关系
- **PrismaModule**: 数据库访问服务
- **class-validator**: 数据验证库
- **@nestjs/swagger**: API文档生成
- **@nestjs/common**: NestJS核心装饰器

---

## 核心功能

### 1. 用户创建
**功能描述**: 创建新用户记录，主要用于微信用户首次登录时
- 必填字段验证（openid）
- 可选字段处理（nickname, avatar, phone）
- 数据库唯一性约束检查
- 异常处理和错误返回

### 2. 用户查询
**单个查询**: 根据用户ID获取用户详细信息
**批量查询**: 获取所有用户列表，支持管理后台使用
**关联查询**: 可扩展支持查询用户的订单历史等关联数据

### 3. 用户更新
**部分更新**: 支持更新用户的部分字段
**字段验证**: 更新时进行数据格式验证
**存在性检查**: 确保更新的用户存在

### 4. 用户删除
**软删除支持**: 可扩展实现软删除功能
**关联检查**: 删除前检查是否有关联订单等数据
**数据完整性**: 确保删除不影响系统数据完整性

---

## API 接口详情

### 📋 接口列表

| 方法 | 路径 | 功能 | 状态码 |
|------|------|------|--------|
| POST | `/users` | 创建用户 | 201, 400 |
| GET | `/users` | 获取所有用户 | 200, 500 |
| GET | `/users/:id` | 获取用户详情 | 200, 404 |
| PATCH | `/users/:id` | 更新用户信息 | 200, 400, 404 |
| DELETE | `/users/:id` | 删除用户 | 200, 404, 409 |

### 🔍 接口详细说明

#### 1. 创建用户
```http
POST /users
Content-Type: application/json

{
  "openid": "wx_openid_123456789",
  "nickname": "小宝贝妈妈",
  "avatar": "https://example.com/avatar.jpg",
  "phone": "13800138000"
}
```

**请求参数**:
- `openid` (必填): 微信用户的openid
- `nickname` (可选): 用户昵称
- `avatar` (可选): 用户头像URL
- `phone` (可选): 用户手机号

**响应示例**:
```json
{
  "id": 1,
  "openid": "wx_openid_123456789",
  "nickname": "小宝贝妈妈",
  "avatar": "https://example.com/avatar.jpg",
  "phone": "13800138000",
  "createdAt": "2024-07-25T10:30:00.000Z",
  "updatedAt": "2024-07-25T10:30:00.000Z"
}
```

#### 2. 获取所有用户
```http
GET /users
```

**响应示例**:
```json
[
  {
    "id": 1,
    "openid": "wx_openid_123456789",
    "nickname": "小宝贝妈妈",
    "avatar": "https://example.com/avatar.jpg",
    "phone": "13800138000",
    "createdAt": "2024-07-25T10:30:00.000Z",
    "updatedAt": "2024-07-25T10:30:00.000Z"
  }
]
```

#### 3. 获取用户详情
```http
GET /users/1
```

**响应示例**:
```json
{
  "id": 1,
  "openid": "wx_openid_123456789",
  "nickname": "小宝贝妈妈",
  "avatar": "https://example.com/avatar.jpg",
  "phone": "13800138000",
  "createdAt": "2024-07-25T10:30:00.000Z",
  "updatedAt": "2024-07-25T10:30:00.000Z"
}
```

#### 4. 更新用户信息
```http
PATCH /users/1
Content-Type: application/json

{
  "nickname": "更新的昵称",
  "phone": "13900139000"
}
```

**响应示例**:
```json
{
  "id": 1,
  "openid": "wx_openid_123456789",
  "nickname": "更新的昵称",
  "avatar": "https://example.com/avatar.jpg",
  "phone": "13900139000",
  "createdAt": "2024-07-25T10:30:00.000Z",
  "updatedAt": "2024-07-25T11:00:00.000Z"
}
```

---

## 数据模型

### 📊 用户数据结构
```typescript
interface User {
  id: number;          // 主键ID
  openid: string;      // 微信openid (唯一)
  nickname?: string;   // 用户昵称 (可选)
  avatar?: string;     // 头像URL (可选)
  phone?: string;      // 手机号 (可选)
  createdAt: Date;     // 创建时间
  updatedAt: Date;     // 更新时间
  
  // 关联关系
  orders?: Order[];    // 用户的订单列表
}
```

### 🔗 关联关系
- **一对多**: User → Order (一个用户可以有多个订单)
- **一对多**: User → Payment (通过订单关联支付记录)
- **一对多**: User → TimeSlot (通过订单关联时间槽)

### 📝 DTO 结构

#### CreateUserDto
```typescript
{
  openid: string;      // 必填，微信openid
  nickname?: string;   // 可选，用户昵称
  avatar?: string;     // 可选，头像URL
  phone?: string;      // 可选，手机号
}
```

#### UpdateUserDto
```typescript
{
  openid?: string;     // 可选，微信openid
  nickname?: string;   // 可选，用户昵称
  avatar?: string;     // 可选，头像URL
  phone?: string;      // 可选，手机号
}
```

---

## 业务逻辑

### 🛡️ 数据验证规则

#### 1. 创建用户验证
- **openid**: 必填，字符串类型
- **nickname**: 可选，字符串类型
- **avatar**: 可选，字符串类型（URL格式验证可扩展）
- **phone**: 可选，字符串类型（手机号格式验证可扩展）

#### 2. 更新用户验证
- 所有字段都是可选的
- 字段类型验证与创建时相同
- 至少需要提供一个字段进行更新

#### 3. 业务规则
- **唯一性**: openid在系统中必须唯一
- **完整性**: 删除用户前需检查关联订单
- **一致性**: 用户信息更新需要保持数据一致性

### 🔄 状态管理
用户模块目前采用简单的活跃状态管理，可扩展为：
- **活跃**: 正常可用状态
- **禁用**: 管理员禁用状态
- **删除**: 软删除状态

---

## 技术实现

### 🔧 核心技术栈
- **NestJS**: Web框架和依赖注入
- **Prisma**: ORM数据库访问
- **TypeScript**: 类型安全
- **class-validator**: 数据验证
- **Swagger**: API文档生成

### 📋 服务实现
```typescript
@Injectable()
export class UsersService {
  constructor(private readonly prisma: PrismaService) {}

  async create(createUserDto: CreateUserDto): Promise<User> {
    try {
      return await this.prisma.user.create({
        data: createUserDto,
      });
    } catch (error) {
      throw new BadRequestException(`Failed to create user: ${error.message}`);
    }
  }

  async findAll(): Promise<User[]> {
    try {
      return await this.prisma.user.findMany();
    } catch (error) {
      throw new InternalServerErrorException(`Failed to fetch users: ${error.message}`);
    }
  }

  async findOne(id: number): Promise<User> {
    const user = await this.prisma.user.findUnique({ where: { id } });
    if (!user) {
      throw new NotFoundException(`User with id ${id} not found`);
    }
    return user;
  }
}
```

### 🗄️ 数据库操作

#### 创建用户
```typescript
await this.prisma.user.create({
  data: {
    openid: dto.openid,
    nickname: dto.nickname,
    avatar: dto.avatar,
    phone: dto.phone,
  },
});
```

#### 查询用户（包含关联数据）
```typescript
await this.prisma.user.findUnique({
  where: { id },
  include: {
    orders: {
      include: {
        package: true,
        timeSlot: true,
        payments: true,
      },
    },
  },
});
```

### 🚦 异常处理
```typescript
// 自定义异常类型
throw new NotFoundException('用户不存在');
throw new BadRequestException('用户创建失败');
throw new InternalServerErrorException('服务器内部错误');

// 统一异常处理
try {
  // 业务逻辑
} catch (error) {
  if (error instanceof NotFoundException) {
    throw error;
  }
  throw new BadRequestException(`操作失败: ${error.message}`);
}
```

---

## 使用示例

### 🎯 前端集成示例

#### 微信小程序集成
```javascript
// 微信小程序用户登录和注册
wx.login({
  success: async (res) => {
    if (res.code) {
      // 获取用户信息
      const userInfo = await wx.getUserProfile({
        desc: '用于完善会员资料'
      });
      
      // 发送到后端创建或更新用户
      const response = await wx.request({
        url: 'https://api.example.com/users',
        method: 'POST',
        data: {
          openid: res.code, // 实际应该通过后端换取openid
          nickname: userInfo.userInfo.nickName,
          avatar: userInfo.userInfo.avatarUrl
        }
      });
      
      // 保存用户信息到本地
      wx.setStorageSync('userInfo', response.data);
    }
  }
});
```

#### React 前端示例
```typescript
// 用户服务类
class UserService {
  private baseURL = '/api/users';

  // 创建用户
  async createUser(userData: CreateUserDto): Promise<User> {
    const response = await fetch(this.baseURL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData),
    });
    
    if (!response.ok) {
      throw new Error('创建用户失败');
    }
    
    return response.json();
  }

  // 获取用户信息
  async getUser(id: number): Promise<User> {
    const response = await fetch(`${this.baseURL}/${id}`);
    
    if (!response.ok) {
      throw new Error('获取用户信息失败');
    }
    
    return response.json();
  }

  // 更新用户信息
  async updateUser(id: number, userData: UpdateUserDto): Promise<User> {
    const response = await fetch(`${this.baseURL}/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData),
    });
    
    if (!response.ok) {
      throw new Error('更新用户信息失败');
    }
    
    return response.json();
  }
}

// React Hook 使用示例
function useUser(userId: number) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const userService = new UserService();

  const fetchUser = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const userData = await userService.getUser(userId);
      setUser(userData);
    } catch (err) {
      setError(err instanceof Error ? err.message : '获取用户失败');
    } finally {
      setLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    if (userId) {
      fetchUser();
    }
  }, [userId, fetchUser]);

  const updateUser = async (updateData: UpdateUserDto) => {
    try {
      const updatedUser = await userService.updateUser(userId, updateData);
      setUser(updatedUser);
      return updatedUser;
    } catch (err) {
      setError(err instanceof Error ? err.message : '更新失败');
      throw err;
    }
  };

  return { user, loading, error, updateUser, refetch: fetchUser };
}

// 用户信息组件
function UserProfile({ userId }: { userId: number }) {
  const { user, loading, error, updateUser } = useUser(userId);
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState<UpdateUserDto>({});

  if (loading) return <div>加载中...</div>;
  if (error) return <div>错误: {error}</div>;
  if (!user) return <div>用户不存在</div>;

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateUser(formData);
      setIsEditing(false);
      alert('更新成功');
    } catch (err) {
      alert('更新失败');
    }
  };

  return (
    <div>
      {!isEditing ? (
        <div>
          <h2>{user.nickname || '未设置昵称'}</h2>
          <img src={user.avatar} alt="头像" />
          <p>手机号: {user.phone || '未设置'}</p>
          <button onClick={() => setIsEditing(true)}>编辑资料</button>
        </div>
      ) : (
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            placeholder="昵称"
            value={formData.nickname || user.nickname || ''}
            onChange={(e) => setFormData({...formData, nickname: e.target.value})}
          />
          <input
            type="text"
            placeholder="手机号"
            value={formData.phone || user.phone || ''}
            onChange={(e) => setFormData({...formData, phone: e.target.value})}
          />
          <button type="submit">保存</button>
          <button type="button" onClick={() => setIsEditing(false)}>取消</button>
        </form>
      )}
    </div>
  );
}
```

### 🔧 管理后台示例
```typescript
// 用户管理页面
function UserManagement() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);
  const userService = new UserService();

  useEffect(() => {
    const fetchUsers = async () => {
      setLoading(true);
      try {
        const userData = await userService.getAllUsers();
        setUsers(userData);
      } catch (err) {
        console.error('获取用户列表失败:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  return (
    <div>
      <h1>用户管理</h1>
      {loading ? (
        <div>加载中...</div>
      ) : (
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>昵称</th>
              <th>手机号</th>
              <th>注册时间</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody>
            {users.map(user => (
              <tr key={user.id}>
                <td>{user.id}</td>
                <td>{user.nickname || '未设置'}</td>
                <td>{user.phone || '未设置'}</td>
                <td>{new Date(user.createdAt).toLocaleDateString()}</td>
                <td>
                  <button onClick={() => viewUserDetail(user.id)}>查看</button>
                  <button onClick={() => editUser(user.id)}>编辑</button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}
```

---

## 安全特性

### 🔒 数据安全
- **输入验证**: 所有输入数据进行格式验证
- **SQL注入防护**: 通过Prisma ORM防止SQL注入
- **数据脱敏**: 敏感信息（如手机号）可实现脱敏显示
- **访问控制**: 可扩展实现基于角色的访问控制

### 🛡️ 隐私保护
- **最小化原则**: 只收集必要的用户信息
- **数据加密**: 敏感数据可实现数据库级别加密
- **审计日志**: 记录用户数据操作日志
- **GDPR合规**: 支持用户数据删除和导出

### 🔐 身份认证
```typescript
// JWT认证装饰器示例
@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    
    if (!token) {
      throw new UnauthorizedException();
    }

    try {
      const payload = this.jwtService.verify(token);
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException();
    }
    
    return true;
  }
}

// 在控制器中使用
@UseGuards(JwtAuthGuard)
@Get('profile')
getProfile(@Request() req) {
  return this.usersService.findOne(req.user.sub);
}
```

---

## 常见问题

### ❓ FAQ

#### Q1: 如何处理微信openid的唯一性冲突？
**A**: 在数据库层面设置openid字段的唯一约束，应用层面捕获冲突异常并返回合适的错误信息。

```typescript
try {
  return await this.prisma.user.create({ data: createUserDto });
} catch (error) {
  if (error.code === 'P2002') { // Prisma唯一约束冲突
    throw new ConflictException('用户已存在');
  }
  throw error;
}
```

#### Q2: 如何实现用户软删除？
**A**: 在User模型中添加deletedAt字段，删除时更新该字段而不是物理删除。

```typescript
// Prisma schema扩展
model User {
  id        Int       @id @default(autoincrement())
  openid    String    @unique
  nickname  String?
  avatar    String?
  phone     String?
  deletedAt DateTime? // 软删除字段
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

// 软删除实现
async softDelete(id: number) {
  return await this.prisma.user.update({
    where: { id },
    data: { deletedAt: new Date() }
  });
}

// 查询时排除已删除用户
async findAll() {
  return await this.prisma.user.findMany({
    where: { deletedAt: null }
  });
}
```

#### Q3: 如何实现用户信息的分页查询？
**A**: 使用Prisma的skip和take参数实现分页。

```typescript
async findAllPaginated(page: number, limit: number) {
  const skip = (page - 1) * limit;
  
  const [users, total] = await Promise.all([
    this.prisma.user.findMany({
      skip,
      take: limit,
      where: { deletedAt: null },
      orderBy: { createdAt: 'desc' }
    }),
    this.prisma.user.count({
      where: { deletedAt: null }
    })
  ]);

  return {
    data: users,
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit)
  };
}
```

#### Q4: 如何验证手机号格式？
**A**: 使用class-validator的装饰器进行手机号格式验证。

```typescript
import { Matches } from 'class-validator';

export class CreateUserDto {
  @ApiProperty({ description: '用户手机号', required: false })
  @IsOptional()
  @IsString()
  @Matches(/^1[3-9]\d{9}$/, { message: '手机号格式不正确' })
  phone?: string;
}
```

#### Q5: 如何处理用户头像上传？
**A**: 可以集成文件上传服务，返回头像URL。

```typescript
@Post('upload-avatar')
@UseInterceptors(FileInterceptor('avatar'))
async uploadAvatar(
  @UploadedFile() file: Express.Multer.File,
  @Param('id') userId: number
) {
  // 上传到云存储服务
  const avatarUrl = await this.fileService.upload(file);
  
  // 更新用户头像
  return await this.usersService.update(userId, {
    avatar: avatarUrl
  });
}
```

### 🐛 故障排除

#### 常见错误及解决方案

1. **用户创建失败**
   ```
   错误: Failed to create user: Unique constraint failed
   解决: 检查openid是否已存在，返回用户已存在的错误
   ```

2. **用户不存在**
   ```
   错误: User with id 1 not found
   解决: 检查用户ID是否正确，确认用户未被删除
   ```

3. **数据验证失败**
   ```
   错误: ValidationError: openid should not be empty
   解决: 确保必填字段已正确提供
   ```

### 📞 技术支持
- **API文档**: 访问 `/api/docs` 查看Swagger文档
- **错误日志**: 查看应用日志获取详细错误信息
- **数据库日志**: 查看数据库操作日志排查问题

---

## 总结

用户模块是整个系统的基础模块，提供了：

✅ **完整的用户管理**: 从创建到删除的全生命周期管理  
✅ **微信集成支持**: 完美集成微信小程序生态  
✅ **灵活的数据结构**: 支持可选字段和扩展需求  
✅ **类型安全**: 完整的TypeScript类型定义  
✅ **RESTful设计**: 标准的REST API接口  
✅ **完整的文档**: 详细的API文档和使用示例  

该模块为整个婴儿摄影工作室系统提供了稳定可靠的用户管理基础，支持后续功能模块的开发和集成。

---

*文档版本: 1.0.0*  
*最后更新: 2024年7月25日*  
*维护者: 开发团队*

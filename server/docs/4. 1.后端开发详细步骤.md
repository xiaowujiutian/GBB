# 4. 后端开发详细步骤

## 4.1 创建 NestJS 项目

```bash
# 创建新项目
nest new baby-photo-backend
选pnpm 
# 进入项目目录
cd baby-photo-backend

# 安装必要的依赖
pnpm install @nestjs/config class-validator class-transformer 
pnpm install @nestjs/swagger swagger-ui-express
```

## 4.2 项目结构设计

```
src/
├── app.module.ts                # 根模块
├── main.ts                      # 入口文件
├── common/                      # 公共模块
│   ├── decorators/             # 自定义装饰器
│   ├── filters/                # 异常过滤器
│   ├── guards/                 # 守卫
│   ├── interceptors/           # 拦截器
│   └── middleware/             # 中间件
├── modules/                     # 核心业务模块
│   ├── users/                  # 用户模块
│   ├── orders/                 # 订单模块
│   ├── payments/               # 支付模块
│   ├── packages/               # 套餐模块
│   └── time-slots/             # 时间槽模块
└── shared/                      # 共享服务
    ├── cache/                  # Redis缓存
    ├── storage/                # 阿里云OSS
    ├── payment/                # 支付服务
    └── queue/                  # 消息队列
```

## 4.3 集成 Prisma ORM 与 PostgreSQL

```bash
# 安装 Prisma
pnpm install prisma --save-dev
pnpm install @prisma/client

# 初始化 Prisma
npx prisma init
```

配置数据库连接:
# 打开 .env 文件
删除或注释掉 prisma+postgres:// 开头的那行，只保留标准 PostgreSQL 连接字符串：
# 注释掉不需要的连接字符串
# DATABASE_URL="prisma+postgres://localhost:51213/?api_key=..."

# 保留这个标准连接字符串
DATABASE_URL="postgresql://postgres:password@localhost:5432/baby_photo_db?schema=public"


创建/home/liyong/gbb/server/baby-photo-backend/prisma/schema.prisma文件 Prisma Schema内容:

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  openid    String   @unique
  nickname  String?
  avatar    String?
  phone     String?
  createdAt DateTime @default(now()) @map("created_at")
  orders    Order[]

  @@map("users")
}

model Package {
  id              Int      @id @default(autoincrement())
  name            String
  description     String?
  price           Decimal  @db.Decimal(10, 2)
  deposit         Decimal  @db.Decimal(10, 2)
  durationMinutes Int      @map("duration_minutes")
  includes        String[]
  createdAt       DateTime @default(now()) @map("created_at")
  orders          Order[]

  @@map("packages")
}

model TimeSlot {
  id        Int      @id @default(autoincrement())
  date      DateTime @db.Date
  startTime DateTime @map("start_time") @db.Time()
  endTime   DateTime @map("end_time") @db.Time()
  isBooked  Boolean  @default(false) @map("is_booked")
  createdAt DateTime @default(now()) @map("created_at")
  orders    Order[]

  @@map("time_slots")
}

model Order {
  id              String    @id @default(uuid())
  orderNo         String    @unique @map("order_no")
  userId          Int       @map("user_id")
  packageId       Int       @map("package_id")
  timeSlotId      Int       @map("time_slot_id")
  appointmentDate DateTime  @map("appointment_date")
  totalAmount     Decimal   @map("total_amount") @db.Decimal(10, 2)
  depositAmount   Decimal   @map("deposit_amount") @db.Decimal(10, 2)
  paidAmount      Decimal   @map("paid_amount") @db.Decimal(10, 2) @default(0)
  paymentStatus   String    @map("payment_status") @default("CREATED")
  orderStatus     String    @map("order_status") @default("CREATED")
  notes           String?
  childrenCount   Int       @map("children_count") @default(1)
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  user            User      @relation(fields: [userId], references: [id])
  package         Package   @relation(fields: [packageId], references: [id])
  timeSlot        TimeSlot  @relation(fields: [timeSlotId], references: [id])
  payments        Payment[]

  @@map("orders")
}

model Payment {
  id            String   @id @default(uuid())
  orderId       String   @map("order_id")
  paymentType   String   @map("payment_type") // DEPOSIT, FULL
  amount        Decimal  @db.Decimal(10, 2)
  status        String   @default("CREATED")
  transactionId String?  @map("transaction_id")
  paidAt        DateTime? @map("paid_at")
  createdAt     DateTime @default(now()) @map("created_at")
  order         Order    @relation(fields: [orderId], references: [id])

  @@map("payments")
}
```
##### 执行4.2的步骤：


生成Prisma客户端:

```bash
npx prisma generate
npx prisma db push
```

##### 创建Prisma服务:
/home/liyong/gbb/server/baby-photo-backend/src/shared/prisma/prisma.service.ts
```typescript

import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  constructor() {
    // 禁用特定行的 ESLint 规则
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    super({
      log: ['query', 'info', 'warn', 'error'] as const,
    });
  }

  async onModuleInit(): Promise<void> {
    // 使用括号包裹以符合 prettier 格式要求
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    void (await this.$connect());
  }

  async onModuleDestroy(): Promise<void> {
    // 使用括号包裹以符合 prettier 格式要求
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    void (await this.$disconnect());
  }
}

```

## 4.4 集成Redis缓存

```bash
# 安装Redis依赖
pnpm install @nestjs/cache-manager cache-manager cache-manager-redis-store redis
```

配置Redis缓存:

```typescript```typescript```typescript```typescript```typescript```typescript```typescript```typescript```typescript```typescript```typescript```typescript```typescript
// filepath: src/shared/cache/cache.module.ts
import { Module } from '@nestjs/common';
import { CacheModule } from '@nestjs/cache-manager';
import { ConfigModule, ConfigService } from '@nestjs/config';
import * as redisStore from 'cache-manager-redis-store';

@Module({
  imports: [
    CacheModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        store: redisStore,
        host: configService.get('REDIS_HOST', 'localhost'),
        port: configService.get('REDIS_PORT', 6379),
        ttl: configService.get('CACHE_TTL', 60), // 默认缓存60秒
      }),
    }),
  ],
  exports: [CacheModule],
})
export class RedisCacheModule {}
```

## 4.5 实现微信支付接口

```bash
# 安装 axios 用于请求
pnpm install axios
```

创建微信支付服务:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import axios from 'axios';
import * as crypto from 'crypto';

@Injectable()
export class WechatPayService {
  private readonly logger = new Logger(WechatPayService.name);
  private readonly appId: string;
  private readonly mchId: string; // 商户号
  private readonly apiKey: string; // API密钥
  private readonly notifyUrl: string;

  constructor(private configService: ConfigService) {
    this.appId = this.configService.get<string>('WECHAT_APPID');
    this.mchId = this.configService.get<string>('WECHAT_MCH_ID');
    this.apiKey = this.configService.get<string>('WECHAT_API_KEY');
    this.notifyUrl = this.configService.get<string>('WECHAT_NOTIFY_URL');
  }

  /**
   * 创建微信支付订单
   */
  async createOrder(params: {
    outTradeNo: string;
    totalFee: number; // 单位：分
    body: string;
    openid: string;
  }) {
    try {
      const nonceStr = this.generateNonceStr();
      
      // 构建请求参数
      const requestData = {
        appid: this.appId,
        mch_id: this.mchId,
        nonce_str: nonceStr,
        body: params.body,
        out_trade_no: params.outTradeNo,
        total_fee: params.totalFee,
        spbill_create_ip: '127.0.0.1', // 服务器IP，可根据实际情况修改
        notify_url: this.notifyUrl,
        trade_type: 'JSAPI', // 小程序支付
        openid: params.openid,
      };

      // 生成签名
      const sign = this.generateSign(requestData);
      
      // 构建最终XML
      const formData = `
        <xml>
          <appid>${this.appId}</appid>
          <mch_id>${this.mchId}</mch_id>
          <nonce_str>${nonceStr}</nonce_str>
          <sign>${sign}</sign>
          <body>${params.body}</body>
          <out_trade_no>${params.outTradeNo}</out_trade_no>
          <total_fee>${params.totalFee}</total_fee>
          <spbill_create_ip>127.0.0.1</spbill_create_ip>
          <notify_url>${this.notifyUrl}</notify_url>
          <trade_type>JSAPI</trade_type>
          <openid>${params.openid}</openid>
        </xml>
      `;

      // 发送请求
      const response = await axios.post('https://api.mch.weixin.qq.com/pay/unifiedorder', 
        formData, {
          headers: { 'Content-Type': 'text/xml' }
        }
      );

      // 解析响应结果
      // 注意：实际应用中需要使用XML解析库处理响应
      this.logger.log(`Payment response: ${JSON.stringify(response.data)}`);
      
      // 返回前端需要的支付参数
      return {
        // 解析XML并返回必要的参数
        // 实际实现中需要处理XML返回值
      };
    } catch (error) {
      this.logger.error(`Create wechat payment error: ${error.message}`);
      throw new Error('创建支付订单失败');
    }
  }

  /**
   * 验证支付回调
   */
  verifyPaymentNotification(xmlData: string) {
    // 解析XML数据
    // 验证签名
    // 返回处理结果
    return {
      success: true,
      outTradeNo: 'xxx', // 商户订单号
      transactionId: 'xxx', // 微信支付订单号
      totalFee: 100 // 订单金额
    };
  }

  /**
   * 生成随机字符串
   */
  private generateNonceStr(length = 32) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }

  /**
   * 生成签名
   */
  private generateSign(params: Record<string, any>) {
    // 按照微信支付签名规则生成签名
    const sortedParams = Object.keys(params)
      .filter(key => params[key] !== undefined && params[key] !== '')
      .sort()
      .map(key => `${key}=${params[key]}`)
      .join('&');
    
    const stringSignTemp = `${sortedParams}&key=${this.apiKey}`;
    return crypto.createHash('md5').update(stringSignTemp).digest('hex').toUpperCase();
  }
}
```

## 4.6 集成阿里云OSS

```bash
# 安装阿里云SDK
npm install ali-oss
```

创建OSS服务:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as OSS from 'ali-oss';

@Injectable()
export class OssService {
  private readonly client: OSS;
  private readonly logger = new Logger(OssService.name);
  private readonly bucket: string;

  constructor(private configService: ConfigService) {
    this.bucket = this.configService.get<string>('OSS_BUCKET');
    
    this.client = new OSS({
      region: this.configService.get<string>('OSS_REGION'),
      accessKeyId: this.configService.get<string>('OSS_ACCESS_KEY_ID'),
      accessKeySecret: this.configService.get<string>('OSS_ACCESS_KEY_SECRET'),
      bucket: this.bucket,
    });
  }

  /**
   * 获取文件上传签名URL
   */
  async getSignedUrl(filename: string, contentType: string, expiresIn = 3600): Promise<string> {
    try {
      const result = await this.client.signatureUrl(filename, {
        method: 'PUT',
        expires: expiresIn,
        'Content-Type': contentType,
      });
      return result;
    } catch (error) {
      this.logger.error(`Get signed URL error: ${error.message}`);
      throw new Error('获取上传签名失败');
    }
  }

  /**
   * 获取文件访问URL
   */
  async getFileUrl(filename: string, expiresIn = 3600): Promise<string> {
    try {
      const result = await this.client.signatureUrl(filename, {
        expires: expiresIn,
      });
      return result;
    } catch (error) {
      this.logger.error(`Get file URL error: ${error.message}`);
      throw new Error('获取文件链接失败');
    }
  }
}
```

## 4.7 实现消息队列

```bash
# 安装Bull消息队列
npm install @nestjs/bull bull
```

配置消息队列:

```typescript
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    BullModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        redis: {
          host: configService.get('REDIS_HOST', 'localhost'),
          port: configService.get<number>('REDIS_PORT', 6379),
        },
      }),
    }),
    BullModule.registerQueue({
      name: 'notifications',
    }),
    BullModule.registerQueue({
      name: 'payments',
    }),
  ],
  exports: [BullModule],
})
export class QueueModule {}
```

## 4.8 实现支付状态机

```typescript
import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../shared/prisma/prisma.service';

export type PaymentState = 'CREATED' | 'PAID' | 'FAILED' | 'REFUNDED';

@Injectable()
export class PaymentStateMachineService {
  private readonly logger = new Logger(PaymentStateMachineService.name);
  private readonly states = {
    CREATED: { to: ['PAID', 'FAILED'] },
    PAID: { to: ['REFUNDED'] },
    FAILED: { to: ['CREATED'] },
    REFUNDED: { to: [] }
  };

  constructor(private readonly prisma: PrismaService) {}

  /**
   * 状态转换
   */
  async transition(paymentId: string, fromState: PaymentState, toState: PaymentState): Promise<void> {
    if (!this.canTransition(fromState, toState)) {
      throw new BadRequestException(`Invalid state transition from ${fromState} to ${toState}`);
    }

    try {
      // 开始事务
      await this.prisma.$transaction(async (tx) => {
        // 更新支付状态
        const payment = await tx.payment.update({
          where: { id: paymentId },
          data: { 
            status: toState,
            ...(toState === 'PAID' ? { paidAt: new Date() } : {})
          },
        });

        // 如果支付成功，更新订单已支付金额和支付状态
        if (toState === 'PAID') {
          await tx.order.update({
            where: { id: payment.orderId },
            data: {
              paidAmount: {
                increment: payment.amount
              },
              paymentStatus: 'PAID'
            }
          });
        }

        this.logger.log(`Payment ${paymentId} transitioned from ${fromState} to ${toState}`);
      });
    } catch (error) {
      this.logger.error(`Payment transition error: ${error.message}`);
      throw new Error('支付状态更新失败');
    }
  }

  /**
   * 检查状态转换是否有效
   */
  private canTransition(fromState: PaymentState, toState: PaymentState): boolean {
    return this.states[fromState]?.to.includes(toState) || false;
  }
}
```

## 4.9 核心模块实现示例

以订单模块为例:

```typescript
import { Module } from '@nestjs/common';
import { OrdersController } from './orders.controller';
import { OrdersService } from './orders.service';
import { PrismaService } from '../../shared/prisma/prisma.service';
import { PaymentStateMachineService } from '../payments/payment-state-machine.service';
import { WechatPayService } from '../../shared/payment/wechat-pay.service';
import { RedisCacheModule } from '../../shared/cache/cache.module';
import { QueueModule } from '../../shared/queue/queue.module';

@Module({
  imports: [RedisCacheModule, QueueModule],
  controllers: [OrdersController],
  providers: [OrdersService, PrismaService, PaymentStateMachineService, WechatPayService],
  exports: [OrdersService],
})
export class OrdersModule {}
```

```typescript
import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../shared/prisma/prisma.service';
import { WechatPayService } from '../../shared/payment/wechat-pay.service';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { Inject } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

@Injectable()
export class OrdersService {
  private readonly logger = new Logger(OrdersService.name);

  constructor(
    private prisma: PrismaService,
    private wechatPayService: WechatPayService,
    @InjectQueue('notifications') private notificationsQueue: Queue,
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
  ) {}

  /**
   * 创建预约订单
   */
  async createOrder(data: {
    userId: number;
    packageId: number;
    timeSlotId: number;
    childrenCount: number;
    paymentType: 'deposit' | 'full';
    notes?: string;
  }) {
    // 生成订单号
    const orderNo = this.generateOrderNo();

    // 获取套餐信息
    const packageInfo = await this.prisma.package.findUnique({
      where: { id: data.packageId },
    });
    if (!packageInfo) {
      throw new NotFoundException('套餐不存在');
    }

    // 检查时间槽是否可用
    const timeSlot = await this.prisma.timeSlot.findUnique({
      where: { id: data.timeSlotId },
    });
    if (!timeSlot || timeSlot.isBooked) {
      throw new NotFoundException('所选时间段不可用');
    }

    try {
      // 使用事务确保数据一致性
      return await this.prisma.$transaction(async (tx) => {
        // 创建订单
        const order = await tx.order.create({
          data: {
            orderNo,
            userId: data.userId,
            packageId: data.packageId,
            timeSlotId: data.timeSlotId,
            appointmentDate: timeSlot.date,
            totalAmount: packageInfo.price,
            depositAmount: packageInfo.deposit,
            childrenCount: data.childrenCount,
            notes: data.notes,
            orderStatus: 'PENDING',
            paymentStatus: 'CREATED',
          },
        });

        // 锁定时间槽
        await tx.timeSlot.update({
          where: { id: data.timeSlotId },
          data: { isBooked: true },
        });

        // 创建支付记录
        const paymentAmount = data.paymentType === 'deposit' 
          ? packageInfo.deposit 
          : packageInfo.price;

        const payment = await tx.payment.create({
          data: {
            orderId: order.id,
            paymentType: data.paymentType.toUpperCase(),
            amount: paymentAmount,
            status: 'CREATED',
          },
        });

        // 返回订单和支付信息
        return { order, payment };
      });
    } catch (error) {
      this.logger.error(`Create order error: ${error.message}`);
      throw new Error('创建订单失败');
    }
  }

  /**
   * 生成订单号
   */
  private generateOrderNo(): string {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    return `ORD${year}${month}${day}${random}`;
  }

  /**
   * 更多方法...
   */
}
```

```typescript
// filepath: src/modules/orders/orders.controller.ts
import { Controller, Post, Body, Get, Param, UseGuards } from '@nestjs/common';
import { OrdersService } from './orders.service';
import { AuthGuard } from '../../common/guards/auth.guard';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';

@ApiTags('订单')
@Controller('orders')
@UseGuards(AuthGuard)
export class OrdersController {
  constructor(private readonly ordersService: OrdersService) {}

  @Post()
  @ApiOperation({ summary: '创建订单' })
  @ApiResponse({ status: 201, description: '订单创建成功' })
  async createOrder(@Body() createOrderDto: any) {
    return this.ordersService.createOrder(createOrderDto);
  }

  @Get(':id')
  @ApiOperation({ summary: '获取订单详情' })
  async getOrder(@Param('id') id: string) {
    // 实现获取订单详情的逻辑
    return { message: '获取订单成功' };
  }

  // 更多端点...
}
```

## 4.10 应用程序入口配置

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { HttpExceptionFilter } from './common/filters/http-exception.filter';
import { ConfigService } from '@nestjs/config';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const configService = app.get(ConfigService);

  // 全局管道 - 验证请求数据
  app.useGlobalPipes(new ValidationPipe({
    transform: true,
    whitelist: true,
    forbidNonWhitelisted: true,
  }));

  // 全局异常过滤器
  app.useGlobalFilters(new HttpExceptionFilter());

  // 配置CORS
  app.enableCors();

  // 配置Swagger文档
  const config = new DocumentBuilder()
    .setTitle('乖宝宝儿童影楼API')
    .setDescription('乖宝宝儿童影楼微信小程序后端API文档')
    .setVersion('1.0')
    .addBearerAuth()
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api-docs', app, document);

  // 获取端口配置
  const port = configService.get<number>('PORT', 3000);
  
  await app.listen(port);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();
```

以上是后端开发的详细步骤，包括项目结构设计、数据库集成、缓存实现、第三方服务集成以及支付状态机的实现。这些步骤为单人全栈开发提供了清晰的后端开发指南。

找到具有 2 个许可证类型的类似代码